if game:GetService("RunService"):IsClient() then error("Please run as a server script. Use h/ instead of hl/.") end
print("FE Compatibility: by WaverlyCole & Mokiros")
InternalData = {}
do
	script.Parent = owner.Character
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput"
	local function NewFakeEvent()
		local Fake = {fakeEvent=true,Connect=function(self,Func)self.Function=Func end}Fake.connect = Fake.Connect
		return Fake
	end
	local Mouse = {Target=nil,Hit=CFrame.new(),KeyUp=NewFakeEvent(),KeyDown=NewFakeEvent(),Button1Up=NewFakeEvent(),Button1Down=NewFakeEvent()}
	local UserInputService = {InputBegan=NewFakeEvent(),InputEnded=NewFakeEvent()}
	local ContextActionService = {Actions={},BindAction = function(self,actionName,Func,touch,...)
		self.Actions[actionName] = Func and {Name=actionName,Function=Func,Keys={...}} or nil
	end};ContextActionService.UnBindAction = ContextActionService.BindAction
	local function TriggerEvent(self,Event,...)
		local Trigger = Mouse[Event]
		if Trigger and Trigger.fakeEvent and Trigger.Function then
			Trigger.Function(...)
		end
	end
	Mouse.TrigEvent = TriggerEvent
	UserInputService.TrigEvent = TriggerEvent
	Event.OnServerEvent:Connect(function(FiredBy,Input)
		if FiredBy.Name ~= owner.Name then end
		if Input.MouseEvent then
			Mouse.Target = Input.Target
			Mouse.Hit = Input.Hit
		else
			local Begin = Input.UserInputState == Enum.UserInputState.Begin
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				return Mouse:TrigEvent(Begin and "Button1Down" or "Button1Up")
			end
			for _,Action in pairs(ContextActionService.Actions) do
				for _,Key in pairs(Action.Keys) do
					if Key==Input.KeyCode then
						Action.Function(Action.Name,Input.UserInputState,Input)
					end
				end
			end
			Mouse:TrigEvent(Begin and "KeyDown" or "KeyUp",Input.KeyCode.Name:lower())
			UserInputService:TrigEvent(Begin and "InputBegan" or "InputEnded",Input,false)
		end
	end)
	InternalData["Mouse"] = Mouse
	InternalData["ContextActionService"] = ContextActionService
	InternalData["UserInputService"] = UserInputService
	Event.Parent = NLS([[
		local Player = owner
		local Event = script:WaitForChild("UserInput")
		local UserInputService = game:GetService("UserInputService")
		local Mouse = Player:GetMouse()
		local Input = function(Input,gameProcessedEvent)
			if gameProcessedEvent then return end
			Event:FireServer({KeyCode=Input.KeyCode,UserInputType=Input.UserInputType,UserInputState=Input.UserInputState})
		end
		UserInputService.InputBegan:Connect(Input)
		UserInputService.InputEnded:Connect(Input)
		local Hit,Target
		while wait(1/30) do
			if Hit ~= Mouse.Hit or Target ~= Mouse.Target then
				Hit,Target = Mouse.Hit,Mouse.Target
				Event:FireServer({["MouseEvent"]=true,["Target"]=Target,["Hit"]=Hit})
			end
		end
	]],owner.Character)
end
RealGame = game;game = setmetatable({},{
	__index = function (self,Index)
		local Sandbox = function (Thing)
			if Thing:IsA("Player") then
				local RealPlayer = Thing
				return setmetatable({},{
					__index = function (self,Index)
						local Type = type(RealPlayer[Index])
						if Type == "function" then
							if Index:lower() == "getmouse" or Index:lower() == "mouse" then
								return function (self)
									return InternalData["Mouse"]
								end
							end
							return function (self,...)
								return RealPlayer[Index](RealPlayer,...)
							end
						else
							if Index == "PlrObj" then
								return RealPlayer
							end
							return RealPlayer[Index]
						end
					end;
					__tostring = function(self)
						return RealPlayer.Name
					end
				})
			end
		end
		if RealGame[Index] then
			local Type = type(RealGame[Index])
			if Type == "function" then
				if Index:lower() == "getservice" or Index:lower() == "service" then
					return function (self,Service)
						if Service:lower() == "players" then
							return setmetatable({},{
								__index = function (self2,Index2)
									local RealService = RealGame:GetService(Service)
									local Type2 = type(Index2)
									if Type2 == "function" then
										return function (self,...)
											return RealService[Index2](RealService,...)
										end
									else
										if Index2:lower() == "localplayer" then
											return Sandbox(owner)
										end
										return RealService[Index2]
									end
								end;
								__tostring = function(self)
									return RealGame:GetService(Service).Name
								end
							})
						elseif Service:lower() == "contextactionservice" then
							return InternalData["ContextActionService"]
						elseif Service:lower() == "contextactionservice" then
							return InternalData["UserInputService"]
						elseif Service:lower() == "runservice" then
							return setmetatable({},{
								__index = function(self2,Index2)
									local RealService = RealGame:GetService(Service)
									local Type2 = type(Index2)
									if Type2 == "function" then
										return function (self,...)
											return RealService[Index2](RealService,...)
										end
									else
										if Index2:lower() == "bindtorenderstep" then
											return function (self,Name,Priority,Function)
												return RealGame:GetService("RunService").Stepped:Connect(Function)
											end
										end
										if Index2:lower() == "renderstepped" then
											return RealService["Stepped"]
										end
										return RealService[Index2]
									end
								end
							})
						else
							return RealGame:GetService(Service)
						end
					end
				end
				return function (self,...)
					return RealGame[Index](RealGame,...)
				end
			else
				if game:GetService(Index) then
					return game:GetService(Index)
				end
				return RealGame[Index]
			end
		else
			return nil
		end
	end
});Game = game;owner = game:GetService("Players").LocalPlayer;script = {}
print("Complete! Running...")


--//Paste script below this line.

return function()
--Converted with ttyyuu12345's model to script plugin v4
function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
ModuleScript0 = Instance.new("ModuleScript")
Script1 = Instance.new("Script")
LocalScript2 = Instance.new("LocalScript")
RemoteEvent3 = Instance.new("RemoteEvent")
RemoteFunction4 = Instance.new("RemoteFunction")
BillboardGui5 = Instance.new("BillboardGui")
TextLabel6 = Instance.new("TextLabel")
Script7 = Instance.new("Script")
MeshPart8 = Instance.new("MeshPart")
MeshPart9 = Instance.new("MeshPart")
MeshPart10 = Instance.new("MeshPart")
Trail11 = Instance.new("Trail")
Script12 = Instance.new("Script")
RemoteEvent13 = Instance.new("RemoteEvent")
RemoteEvent14 = Instance.new("RemoteEvent")
RemoteEvent15 = Instance.new("RemoteEvent")
BillboardGui16 = Instance.new("BillboardGui")
ImageLabel17 = Instance.new("ImageLabel")
Script18 = Instance.new("Script")
MeshPart19 = Instance.new("MeshPart")
RemoteEvent20 = Instance.new("RemoteEvent")
RemoteEvent21 = Instance.new("RemoteEvent")
RemoteEvent22 = Instance.new("RemoteEvent")
Folder23 = Instance.new("Folder")
ParticleEmitter24 = Instance.new("ParticleEmitter")
ParticleEmitter25 = Instance.new("ParticleEmitter")
ParticleEmitter26 = Instance.new("ParticleEmitter")
ParticleEmitter27 = Instance.new("ParticleEmitter")
Part28 = Instance.new("Part")
SpecialMesh29 = Instance.new("SpecialMesh")
Script30 = Instance.new("Script")
Model31 = Instance.new("Model")
Part32 = Instance.new("Part")
Motor6D33 = Instance.new("Motor6D")
Motor6D34 = Instance.new("Motor6D")
Motor6D35 = Instance.new("Motor6D")
Motor6D36 = Instance.new("Motor6D")
Motor6D37 = Instance.new("Motor6D")
ParticleEmitter38 = Instance.new("ParticleEmitter")
Part39 = Instance.new("Part")
ParticleEmitter40 = Instance.new("ParticleEmitter")
Part41 = Instance.new("Part")
ParticleEmitter42 = Instance.new("ParticleEmitter")
Part43 = Instance.new("Part")
ParticleEmitter44 = Instance.new("ParticleEmitter")
Part45 = Instance.new("Part")
ParticleEmitter46 = Instance.new("ParticleEmitter")
Part47 = Instance.new("Part")
ParticleEmitter48 = Instance.new("ParticleEmitter")
Humanoid49 = Instance.new("Humanoid")
Script50 = Instance.new("Script")
StringValue51 = Instance.new("StringValue")
Animation52 = Instance.new("Animation")
StringValue53 = Instance.new("StringValue")
Animation54 = Instance.new("Animation")
StringValue55 = Instance.new("StringValue")
Animation56 = Instance.new("Animation")
NumberValue57 = Instance.new("NumberValue")
Animation58 = Instance.new("Animation")
NumberValue59 = Instance.new("NumberValue")
StringValue60 = Instance.new("StringValue")
Animation61 = Instance.new("Animation")
StringValue62 = Instance.new("StringValue")
Animation63 = Instance.new("Animation")
StringValue64 = Instance.new("StringValue")
Animation65 = Instance.new("Animation")
StringValue66 = Instance.new("StringValue")
Animation67 = Instance.new("Animation")
ObjectValue68 = Instance.new("ObjectValue")
Script69 = Instance.new("Script")
LocalScript70 = Instance.new("LocalScript")
RemoteEvent71 = Instance.new("RemoteEvent")
ParticleEmitter72 = Instance.new("ParticleEmitter")
MeshPart73 = Instance.new("MeshPart")
MeshPart74 = Instance.new("MeshPart")
ScreenGui75 = Instance.new("ScreenGui")
Frame76 = Instance.new("Frame")
Frame77 = Instance.new("Frame")
LocalScript78 = Instance.new("LocalScript")
Frame79 = Instance.new("Frame")
TextLabel80 = Instance.new("TextLabel")
TextLabel81 = Instance.new("TextLabel")
RemoteFunction82 = Instance.new("RemoteFunction")
ModuleScript83 = Instance.new("ModuleScript")
ScreenGui84 = Instance.new("ScreenGui")
LocalScript85 = Instance.new("LocalScript")
Folder86 = Instance.new("Folder")
BindableEvent87 = Instance.new("BindableEvent")
RemoteEvent88 = Instance.new("RemoteEvent")
RemoteEvent89 = Instance.new("RemoteEvent")
RemoteEvent90 = Instance.new("RemoteEvent")
RemoteEvent91 = Instance.new("RemoteEvent")
ModuleScript0.Name = "MainModule"
ModuleScript0.Parent = mas
table.insert(cors,sandbox(ModuleScript0,function()
return function(n)
	if game.Players:FindFirstChild(n) then
		local scr = script.MOU:Clone()
		for i,v in pairs(script.Remotes:GetChildren()) do
			if game.ReplicatedStorage:FindFirstChild(v.Name)==nil then
				v:Clone().Parent = game.ReplicatedStorage
			end
		end
		scr.Parent = game.Players[n].Character
		scr.Disabled = false
		for i,v in pairs(game.Players:GetPlayers()) do
			if v.PlayerGui:FindFirstChild("ReplicatedEffects")==nil then
				script.ReplicatedEffects:Clone().Parent = v.PlayerGui
			end
		end
		game.Players.PlayerAdded:Connect(function(v)
			wait(1/60)
			if v.PlayerGui:FindFirstChild("ReplicatedEffects")==nil then
				script.ReplicatedEffects:Clone().Parent = v.PlayerGui
			end
		end)
	end
end
end))
Script1.Name = "MOU"
Script1.Parent = ModuleScript0
Script1.Disabled = true
LocalScript2.Name = "local"
LocalScript2.Parent = Script1
table.insert(cors,sandbox(LocalScript2,function()
wait(1)
local m = game:GetService("Players").LocalPlayer:GetMouse()
m.Button1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("mouse")
end)
m.KeyDown:Connect(function(key)
	key=key:lower()
	script.Parent.RemoteEvent:FireServer("keydown",key)
end)
m.KeyUp:Connect(function(key)
	key=key:lower()
	script.Parent.RemoteEvent:FireServer("keyup",key)
end)
script.Parent:WaitForChild('hit')
script.Parent.hit.OnClientInvoke = function(plr)
	return m.Hit, m.Target
end
local p = game:GetService("Players").LocalPlayer
local gui = Instance.new('ScreenGui', p.PlayerGui)
	gui.Name = 'cre'
	local lab = Instance.new('TextLabel', gui)
	lab.Position = UDim2.new(0, 0, .8, 0)
	lab.Text = ""
	lab.BackgroundTransparency = 1
	lab.Font = Enum.Font.Arcade
	lab.TextSize = 18
	lab.TextColor3 = Color3.new(1,1,1)
	lab.TextStrokeTransparency = .1
	lab.TextXAlignment = Enum.TextXAlignment.Left
	local lab2 = Instance.new('TextLabel', gui)
	lab2.Position = UDim2.new(0, 0, .75, 0)
	lab2.Text = ""
	lab2.BackgroundTransparency = 1
	lab2.Font = Enum.Font.Arcade
	lab2.TextSize = 18
	lab2.TextColor3 = Color3.new(1,1,1)
	lab2.TextStrokeTransparency = .1
	lab2.Size = UDim2.new(1,0,.05,0)
	lab2.TextXAlignment = Enum.TextXAlignment.Left
	local lab3 = Instance.new('TextLabel', gui)
	lab3.Position = UDim2.new(0, 0, .7, 0)
	lab3.Text = ""
	lab3.BackgroundTransparency = 1
	lab3.Font = Enum.Font.Arcade
	lab3.TextSize = 18
	lab3.TextColor3 = Color3.new(1,1,1)
	lab3.TextStrokeTransparency = .1
	lab3.Size = UDim2.new(1,0,.05,0)
	lab3.TextXAlignment = Enum.TextXAlignment.Left
	local lab4 = Instance.new('TextLabel', gui)
	lab4.Position = UDim2.new(0, 0, .65, 0)
	lab4.Text = ""
	lab4.BackgroundTransparency = 1
	lab4.Font = Enum.Font.Arcade
	lab4.TextSize = 18
	lab4.TextColor3 = Color3.new(1,1,1)
	lab4.TextStrokeTransparency = .1
	lab4.Size = UDim2.new(1,0,.05,0)
	lab4.TextXAlignment = Enum.TextXAlignment.Left
	local bar = Instance.new("Frame", gui)
	bar.Size = UDim2.new(.2,0,.03, 0)
	bar.BackgroundColor3 = Color3.new(0,0,0)
	bar.BorderSizePixel = 3
	bar.Position = UDim2.new(0,0,.6,0)
	local fill = Instance.new('Frame', bar)
	fill.Size = UDim2.new(1,0,1,0)
	fill.BorderSizePixel = 0
	fill.BackgroundColor3 = Color3.new(0,0,1)

local input = Instance.new("TextBox")
local chrg = Instance.new("TextButton")
local a = Instance.new("TextButton")
local b = Instance.new("TextButton")
local c = Instance.new("TextButton")
local d = Instance.new("TextButton")
local e = Instance.new("TextButton")

input.Name = "input"
input.Parent = gui
input.BackgroundColor3 = Color3.new(1, 0, 0)
input.BackgroundTransparency = 0.5
input.Position = UDim2.new(0.78938663, 0, 0.0160427801, 0)
input.Size = UDim2.new(0, 140, 0, 36)
input.Font = Enum.Font.SourceSans
input.PlaceholderText = "Key Input"
input.Text = ""
input.TextColor3 = Color3.new(1, 1, 1)
input.TextScaled = true
input.TextSize = 14
input.TextWrapped = true

chrg.Name = "chrg"
chrg.Parent = gui
chrg.BackgroundColor3 = Color3.new(1, 0, 0)
chrg.BackgroundTransparency = 0.40000000596046
chrg.Position = UDim2.new(0.180180177, 0, 0.834175885, 0)
chrg.Size = UDim2.new(0, 141, 0, 34)
chrg.Font = Enum.Font.SourceSans
chrg.Text = "Charge"
chrg.TextColor3 = Color3.new(1, 1, 1)
chrg.TextScaled = true
chrg.TextSize = 14
chrg.TextWrapped = true

a.Name = "a"
a.Parent = gui
a.BackgroundColor3 = Color3.new(1, 0, 0)
a.BackgroundTransparency = 0.40000000596046
a.Position = UDim2.new(0.42492494, 0, 0.834175885, 0)
a.Size = UDim2.new(0, 141, 0, 34)
a.Font = Enum.Font.SourceSans
a.Text = "AttackOne"
a.TextColor3 = Color3.new(1, 1, 1)
a.TextScaled = true
a.TextSize = 14
a.TextWrapped = true

b.Name = "b"
b.Parent = gui
b.BackgroundColor3 = Color3.new(1, 0, 0)
b.BackgroundTransparency = 0.40000000596046
b.Position = UDim2.new(0.659159124, 0, 0.834175885, 0)
b.Size = UDim2.new(0, 141, 0, 34)
b.Font = Enum.Font.SourceSans
b.Text = "AttackTwo"
b.TextColor3 = Color3.new(1, 1, 1)
b.TextScaled = true
b.TextSize = 14
b.TextWrapped = true

c.Name = "c"
c.Parent = gui
c.BackgroundColor3 = Color3.new(1, 0, 0)
c.BackgroundTransparency = 0.40000000596046
c.Position = UDim2.new(0.180180192, 0, 0.68711704, 0)
c.Size = UDim2.new(0, 141, 0, 34)
c.Font = Enum.Font.SourceSans
c.Text = "AttackThree"
c.TextColor3 = Color3.new(1, 1, 1)
c.TextScaled = true
c.TextSize = 14
c.TextWrapped = true

d.Name = "d"
d.Parent = gui
d.BackgroundColor3 = Color3.new(1, 0, 0)
d.BackgroundTransparency = 0.40000000596046
d.Position = UDim2.new(0.42492494, 0, 0.68711704, 0)
d.Size = UDim2.new(0, 141, 0, 34)
d.Font = Enum.Font.SourceSans
d.Text = "Midnight"
d.TextColor3 = Color3.new(1, 1, 1)
d.TextScaled = true
d.TextSize = 14
d.TextWrapped = true

e.Name = "e"
e.Parent = gui
e.BackgroundColor3 = Color3.new(1, 0, 0)
e.BackgroundTransparency = 0.40000000596046
e.Position = UDim2.new(0.657657683, 0, 0.68711704, 0)
e.Size = UDim2.new(0, 141, 0, 34)
e.Font = Enum.Font.SourceSans
e.Text = "Rainbow"
e.TextColor3 = Color3.new(1, 1, 1)
e.TextScaled = true
e.TextSize = 14
e.TextWrapped = true

chrg.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","c")
end)
chrg.MouseButton1Up:Connect(function()
	script.Parent.RemoteEvent:FireServer("keyup","c")
end)
a.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","e")
end)
b.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","q")
end)
c.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","r")
end)
d.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","m")
end)
e.MouseButton1Down:Connect(function()
	script.Parent.RemoteEvent:FireServer("keydown","h")
end)
input.FocusLost:Connect(function()
	local chars = input.Text
	for i=1,#chars do
		script.Parent.RemoteEvent:FireServer("keydown",chars:sub(i,i))
		wait()
	end
end)

script.Parent.cr.OnClientEvent:Connect(function(k)
	lab.Text = lab.Text .. k.. "\32\32"
end)
script.Parent.clr.OnClientEvent:Connect(function(p)
	lab.Text = ""
end)
script.Parent.val.OnClientEvent:Connect(function(p)
	local f = lab:Clone()
	f.Parent = gui
	f.TextColor3 = Color3.new(0,1,0)
	spawn(function()
		for i=0,1,0.04 do
			f.TextSize = f.TextSize + 1
			f.TextTransparency = i
			f.TextStrokeTransparency = i
			game:GetService("RunService").RenderStepped:Wait(0)
		end
		f:Destroy()
	end)
end)
local kills = 0
local level = 1
local xp = 0
local goal = 100
local max = 5000
local plr = game:GetService("Players").LocalPlayer
if plr:FindFirstChild("level") then
	level = plr.level.Value
end
script.Parent.kills.OnClientEvent:Connect(function(n,gain)
	kills=kills+n
	xp = xp + math.random(1,50) + gain
	print(goal-xp)
	if (goal-xp) <= 0 then
		xp = xp - goal
		goal = goal + math.random(30,255)
		level = level + 1
	end
end)
local mana = 0
script.Parent.mana.OnClientEvent:Connect(function(n)
	mana = n
end)

game:GetService("RunService").RenderStepped:Connect(function()
	lab2.Text = "Kills: ".. kills
	lab3.Text = "Level: ".. level
	lab4.Text = "Next: ".. goal-xp
	fill.Size = UDim2.new(mana/max,0,1,0)
	script.Parent.level:FireServer(level)
end)
local mouse = plr:GetMouse()
script.Parent:WaitForChild("Mouse").OnClientInvoke = function()
	return {Hit=mouse.Hit, Target=mouse.Target}
end
end))
RemoteEvent3.Name = "kills"
RemoteEvent3.Parent = Script1
RemoteFunction4.Name = "hit"
RemoteFunction4.Parent = Script1
BillboardGui5.Name = "name"
BillboardGui5.Parent = Script1
BillboardGui5.LightInfluence = 1
BillboardGui5.Size = UDim2.new(30, 0, 2, 0)
BillboardGui5.Active = true
BillboardGui5.ClipsDescendants = true
BillboardGui5.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
BillboardGui5.AlwaysOnTop = true
BillboardGui5.SizeOffset = Vector2.new(0, 1.5)
TextLabel6.Parent = BillboardGui5
TextLabel6.Size = UDim2.new(1, 0, 1, 0)
TextLabel6.BackgroundColor = BrickColor.new("Crimson")
TextLabel6.BackgroundColor3 = Color3.new(0.67451, 0.0235294, 0.0235294)
TextLabel6.BackgroundTransparency = 1
TextLabel6.Font = Enum.Font.SourceSans
TextLabel6.FontSize = Enum.FontSize.Size14
TextLabel6.Text = "Universal"
TextLabel6.TextColor = BrickColor.new("Crimson")
TextLabel6.TextColor3 = Color3.new(0.67451, 0.0235294, 0.0235294)
TextLabel6.TextScaled = true
TextLabel6.TextSize = 14
TextLabel6.TextWrap = true
TextLabel6.TextWrapped = true
Script7.Parent = TextLabel6
table.insert(cors,sandbox(Script7,function()
game:GetService("RunService").Stepped:Connect(function()
	local font = math.random(1,4)
	if font == 1 then
		script.Parent.Font = Enum.Font.Arcade
	elseif font == 2 then
		script.Parent.Font = Enum.Font.Cartoon
	elseif font == 3 then
		script.Parent.Font = Enum.Font.Code
	elseif font == 4 then
		script.Parent.Font = Enum.Font.Gotham
	end
end)
end))
MeshPart8.Name = "Halo"
MeshPart8.Parent = Script1
MeshPart8.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart8.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart8.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart8.Size = Vector3.new(2, 2, 0.159999996)
MeshPart8.BrickColor = BrickColor.new("Institutional white")
MeshPart8.CanCollide = false
MeshPart8.Material = Enum.Material.Neon
MeshPart8.brickColor = BrickColor.new("Institutional white")
MeshPart9.Name = "Halo2"
MeshPart9.Parent = Script1
MeshPart9.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart9.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart9.Color = Color3.new(0.972549, 0.972549, 0.972549)
MeshPart9.Size = Vector3.new(4, 4, 0.159999996)
MeshPart9.BrickColor = BrickColor.new("Institutional white")
MeshPart9.CanCollide = false
MeshPart9.Material = Enum.Material.Neon
MeshPart9.brickColor = BrickColor.new("Institutional white")
MeshPart10.Name = "Shard1"
MeshPart10.Parent = Script1
MeshPart10.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart10.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart10.Color = Color3.new(0.384314, 0.145098, 0.819608)
MeshPart10.Size = Vector3.new(0.914209843, 3.01420927, 0.900000095)
MeshPart10.BrickColor = BrickColor.new("Royal purple")
MeshPart10.CanCollide = false
MeshPart10.Material = Enum.Material.Neon
MeshPart10.brickColor = BrickColor.new("Royal purple")
Trail11.Parent = MeshPart10
Trail11.Attachment0 = nil
Trail11.Attachment1 = nil
Trail11.LightInfluence = 1
Trail11.TextureMode = Enum.TextureMode.Wrap
Trail11.Transparency = NumberSequence.new(0,1)
Trail11.Lifetime = 0.30000001192093
Trail11.WidthScale = NumberSequence.new(1,0)
Script12.Parent = Trail11
table.insert(cors,sandbox(Script12,function()
game:GetService("RunService").Stepped:Connect(function()
	script.Parent.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0,script.Parent.Parent.BrickColor.Color),
		ColorSequenceKeypoint.new(1,script.Parent.Parent.BrickColor.Color)
	})
end)
end))
RemoteEvent13.Name = "cr"
RemoteEvent13.Parent = Script1
RemoteEvent14.Name = "clr"
RemoteEvent14.Parent = Script1
RemoteEvent15.Name = "val"
RemoteEvent15.Parent = Script1
BillboardGui16.Name = "geno"
BillboardGui16.Parent = Script1
BillboardGui16.LightInfluence = 1
BillboardGui16.Size = UDim2.new(9, 0, 9, 0)
BillboardGui16.Active = true
BillboardGui16.ClipsDescendants = true
BillboardGui16.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
BillboardGui16.AlwaysOnTop = true
ImageLabel17.Parent = BillboardGui16
ImageLabel17.Size = UDim2.new(1, 0, 1, 0)
ImageLabel17.BackgroundColor = BrickColor.new("Institutional white")
ImageLabel17.BackgroundColor3 = Color3.new(1, 1, 1)
ImageLabel17.BackgroundTransparency = 1
ImageLabel17.Image = "rbxassetid://711463989"
ImageLabel17.ImageColor3 = Color3.new(1, 0, 0)
Script18.Parent = ImageLabel17
table.insert(cors,sandbox(Script18,function()
game:GetService("RunService").Stepped:Connect(function()
	script.Parent.Rotation = script.Parent.Rotation + 1
end)
end))
MeshPart19.Name = "Sloce"
MeshPart19.Parent = Script1
MeshPart19.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart19.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart19.Size = Vector3.new(1, 0.0500000007, 1)
MeshPart19.CanCollide = false
MeshPart19.Material = Enum.Material.Neon
RemoteEvent20.Parent = Script1
RemoteEvent21.Name = "level"
RemoteEvent21.Parent = Script1
RemoteEvent22.Name = "mana"
RemoteEvent22.Parent = Script1
Folder23.Name = "Particles"
Folder23.Parent = Script1
ParticleEmitter24.Name = "Inner"
ParticleEmitter24.Parent = Folder23
ParticleEmitter24.Speed = NumberRange.new(0, 0)
ParticleEmitter24.Rotation = NumberRange.new(-20, 20)
ParticleEmitter24.Enabled = false
ParticleEmitter24.LightEmission = 0.40000000596046
ParticleEmitter24.LightInfluence = 1
ParticleEmitter24.Texture = "rbxassetid://1167543441"
ParticleEmitter24.Transparency = NumberSequence.new(0,0.4355828166008,0.87730062007904,1,1)
ParticleEmitter24.ZOffset = 0.10000000149012
ParticleEmitter24.Size = NumberSequence.new(0,1.3496935367584,7.5460124015808)
ParticleEmitter24.Lifetime = NumberRange.new(1, 1)
ParticleEmitter24.LockedToPart = true
ParticleEmitter25.Name = "Outer"
ParticleEmitter25.Parent = Folder23
ParticleEmitter25.Speed = NumberRange.new(0, 0)
ParticleEmitter25.Rotation = NumberRange.new(-20, 20)
ParticleEmitter25.Color = ColorSequence.new(Color3.new(1, 0.807843, 0.113725),Color3.new(1, 0.807843, 0.113725))
ParticleEmitter25.Enabled = false
ParticleEmitter25.LightInfluence = 1
ParticleEmitter25.Texture = "rbxassetid://1167543441"
ParticleEmitter25.Transparency = NumberSequence.new(0,0.24539881944656,1)
ParticleEmitter25.Size = NumberSequence.new(0,5.337423324585,10)
ParticleEmitter25.Lifetime = NumberRange.new(1, 1)
ParticleEmitter25.LockedToPart = true
ParticleEmitter26.Name = "s1"
ParticleEmitter26.Parent = Script1
ParticleEmitter26.Speed = NumberRange.new(0, 0)
ParticleEmitter26.LightEmission = 1
ParticleEmitter26.LightInfluence = 1
ParticleEmitter26.Transparency = NumberSequence.new(0,1)
ParticleEmitter26.Lifetime = NumberRange.new(4, 4)
ParticleEmitter26.Rate = 1
ParticleEmitter26.RotSpeed = NumberRange.new(60, 60)
ParticleEmitter27.Name = "s2"
ParticleEmitter27.Parent = Script1
ParticleEmitter27.Speed = NumberRange.new(10, 10)
ParticleEmitter27.LightEmission = 1
ParticleEmitter27.LightInfluence = 1
ParticleEmitter27.Size = NumberSequence.new(0.10000000149012,0)
ParticleEmitter27.Lifetime = NumberRange.new(1, 1)
ParticleEmitter27.Rate = 300
ParticleEmitter27.RotSpeed = NumberRange.new(60, 60)
ParticleEmitter27.SpreadAngle = Vector2.new(-360, 360)
ParticleEmitter27.VelocitySpread = -360
Part28.Name = "FF"
Part28.Parent = Script1
Part28.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part28.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
Part28.Color = Color3.new(0.384314, 0.145098, 0.819608)
Part28.Size = Vector3.new(30, 30, 30)
Part28.BottomSurface = Enum.SurfaceType.Smooth
Part28.BrickColor = BrickColor.new("Royal purple")
Part28.CanCollide = false
Part28.Material = Enum.Material.ForceField
Part28.TopSurface = Enum.SurfaceType.Smooth
Part28.brickColor = BrickColor.new("Royal purple")
SpecialMesh29.Parent = Part28
SpecialMesh29.MeshId = "rbxassetid://2936644507"
SpecialMesh29.Scale = Vector3.new(8, 8, 8)
SpecialMesh29.TextureId = "rbxassetid://1096645367"
SpecialMesh29.MeshType = Enum.MeshType.FileMesh
Script30.Parent = Part28
table.insert(cors,sandbox(Script30,function()
script.Parent.Touched:Connect(function(hit)
	if hit.Parent:FindFirstChildOfClass('Humanoid') then
		hit.Parent:FindFirstChildOfClass('Humanoid').Health = hit.Parent:FindFirstChildOfClass('Humanoid').MaxHealth
	end
end)
end))
Model31.Name = "Phantom"
Model31.Parent = Script1
Model31.PrimaryPart = Part47
Part32.Name = "Torso"
Part32.Parent = Model31
Part32.CFrame = CFrame.new(-458.061981, -397, 51.3892365, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part32.Position = Vector3.new(-458.061981, -397, 51.3892365)
Part32.Color = Color3.new(0.458824, 0, 0)
Part32.Transparency = 0.5
Part32.Size = Vector3.new(2, 2, 1)
Part32.BottomSurface = Enum.SurfaceType.Smooth
Part32.BrickColor = BrickColor.new("Maroon")
Part32.CanCollide = false
Part32.Material = Enum.Material.Glass
Part32.TopSurface = Enum.SurfaceType.Smooth
Part32.brickColor = BrickColor.new("Maroon")
Motor6D33.Name = "Left Hip"
Motor6D33.Parent = Part32
Motor6D33.MaxVelocity = 0.10000000149012
Motor6D33.C0 = CFrame.new(-1, -1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
Motor6D33.C1 = CFrame.new(-0.5, 1, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
Motor6D33.Part0 = Part32
Motor6D33.Part1 = Part39
Motor6D33.part1 = Part39
Motor6D34.Name = "Right Hip"
Motor6D34.Parent = Part32
Motor6D34.MaxVelocity = 0.10000000149012
Motor6D34.C0 = CFrame.new(1, -1, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08)
Motor6D34.C1 = CFrame.new(0.5, 1, 0, -4.37113883e-08, 0, 1, 0, 0.99999994, 0, -1, 0, -4.37113883e-08)
Motor6D34.Part0 = Part32
Motor6D34.Part1 = Part41
Motor6D34.part1 = Part41
Motor6D35.Name = "Left Shoulder"
Motor6D35.Parent = Part32
Motor6D35.MaxVelocity = 0.10000000149012
Motor6D35.C0 = CFrame.new(-1, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
Motor6D35.C1 = CFrame.new(0.5, 0.5, 0, -4.37113883e-08, 0, -1, 0, 0.99999994, 0, 1, 0, -4.37113883e-08)
Motor6D35.Part0 = Part32
Motor6D35.Part1 = Part43
Motor6D35.part1 = Part43
Motor6D36.Name = "Right Shoulder"
Motor6D36.Parent = Part32
Motor6D36.MaxVelocity = 0.10000000149012
Motor6D36.C0 = CFrame.new(1, 0.5, 0, -4.37113883e-08, 0, 1, -0, 0.99999994, 0, -1, 0, -4.37113883e-08)
Motor6D36.C1 = CFrame.new(-0.5, 0.5, 0, -4.37113883e-08, 0, 1, 0, 0.99999994, 0, -1, 0, -4.37113883e-08)
Motor6D36.Part0 = Part32
Motor6D36.Part1 = Part45
Motor6D36.part1 = Part45
Motor6D37.Name = "Neck"
Motor6D37.Parent = Part32
Motor6D37.MaxVelocity = 0.10000000149012
Motor6D37.C0 = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D37.C1 = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
Motor6D37.Part0 = Part32
Motor6D37.Part1 = Part47
Motor6D37.part1 = Part47
ParticleEmitter38.Parent = Part32
ParticleEmitter38.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter38.LightInfluence = 1
ParticleEmitter38.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter38.Size = NumberSequence.new(1,0)
ParticleEmitter38.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter38.Rate = 30
ParticleEmitter38.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter38.VelocitySpread = -50
Part39.Name = "Left Leg"
Part39.Parent = Model31
Part39.CFrame = CFrame.new(-458.561981, -399, 51.3892365, 1, 0, 0, 0, 0.999999881, 0, 0, 0, 1)
Part39.Position = Vector3.new(-458.561981, -399, 51.3892365)
Part39.Color = Color3.new(0.458824, 0, 0)
Part39.Transparency = 0.5
Part39.Size = Vector3.new(1, 2, 1)
Part39.BottomSurface = Enum.SurfaceType.Smooth
Part39.BrickColor = BrickColor.new("Maroon")
Part39.CanCollide = false
Part39.Material = Enum.Material.Glass
Part39.TopSurface = Enum.SurfaceType.Smooth
Part39.brickColor = BrickColor.new("Maroon")
ParticleEmitter40.Parent = Part39
ParticleEmitter40.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter40.LightInfluence = 1
ParticleEmitter40.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter40.Size = NumberSequence.new(1,0)
ParticleEmitter40.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter40.Rate = 30
ParticleEmitter40.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter40.VelocitySpread = -50
Part41.Name = "Right Leg"
Part41.Parent = Model31
Part41.CFrame = CFrame.new(-457.561981, -399, 51.3892365, 1, 0, 0, 0, 0.999999881, 0, 0, 0, 1)
Part41.Position = Vector3.new(-457.561981, -399, 51.3892365)
Part41.Color = Color3.new(0.458824, 0, 0)
Part41.Transparency = 0.5
Part41.Size = Vector3.new(1, 2, 1)
Part41.BottomSurface = Enum.SurfaceType.Smooth
Part41.BrickColor = BrickColor.new("Maroon")
Part41.CanCollide = false
Part41.Material = Enum.Material.Glass
Part41.TopSurface = Enum.SurfaceType.Smooth
Part41.brickColor = BrickColor.new("Maroon")
ParticleEmitter42.Parent = Part41
ParticleEmitter42.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter42.LightInfluence = 1
ParticleEmitter42.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter42.Size = NumberSequence.new(1,0)
ParticleEmitter42.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter42.Rate = 30
ParticleEmitter42.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter42.VelocitySpread = -50
Part43.Name = "Left Arm"
Part43.Parent = Model31
Part43.CFrame = CFrame.new(-459.561981, -397, 51.3892365, 1, 0, 0, 0, 0.999999881, 0, 0, 0, 1)
Part43.Position = Vector3.new(-459.561981, -397, 51.3892365)
Part43.Color = Color3.new(0.458824, 0, 0)
Part43.Transparency = 0.5
Part43.Size = Vector3.new(1, 2, 1)
Part43.BottomSurface = Enum.SurfaceType.Smooth
Part43.BrickColor = BrickColor.new("Maroon")
Part43.CanCollide = false
Part43.Material = Enum.Material.Glass
Part43.TopSurface = Enum.SurfaceType.Smooth
Part43.brickColor = BrickColor.new("Maroon")
ParticleEmitter44.Parent = Part43
ParticleEmitter44.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter44.LightInfluence = 1
ParticleEmitter44.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter44.Size = NumberSequence.new(1,0)
ParticleEmitter44.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter44.Rate = 30
ParticleEmitter44.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter44.VelocitySpread = -50
Part45.Name = "Right Arm"
Part45.Parent = Model31
Part45.CFrame = CFrame.new(-456.561981, -397, 51.3892365, 1, 0, 0, 0, 0.999999881, 0, 0, 0, 1)
Part45.Position = Vector3.new(-456.561981, -397, 51.3892365)
Part45.Color = Color3.new(0.458824, 0, 0)
Part45.Transparency = 0.5
Part45.Size = Vector3.new(1, 2, 1)
Part45.BottomSurface = Enum.SurfaceType.Smooth
Part45.BrickColor = BrickColor.new("Maroon")
Part45.CanCollide = false
Part45.Material = Enum.Material.Glass
Part45.TopSurface = Enum.SurfaceType.Smooth
Part45.brickColor = BrickColor.new("Maroon")
ParticleEmitter46.Parent = Part45
ParticleEmitter46.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter46.LightInfluence = 1
ParticleEmitter46.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter46.Size = NumberSequence.new(1,0)
ParticleEmitter46.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter46.Rate = 30
ParticleEmitter46.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter46.VelocitySpread = -50
Part47.Name = "Head"
Part47.Parent = Model31
Part47.CFrame = CFrame.new(-458.061981, -395.5, 51.3892365, 1, 0, 0, 0, 1, 0, 0, 0, 1)
Part47.Position = Vector3.new(-458.061981, -395.5, 51.3892365)
Part47.Color = Color3.new(0.458824, 0, 0)
Part47.Transparency = 0.5
Part47.Size = Vector3.new(1, 1, 1)
Part47.BottomSurface = Enum.SurfaceType.Smooth
Part47.BrickColor = BrickColor.new("Maroon")
Part47.Material = Enum.Material.Glass
Part47.TopSurface = Enum.SurfaceType.Smooth
Part47.brickColor = BrickColor.new("Maroon")
ParticleEmitter48.Parent = Part47
ParticleEmitter48.Color = ColorSequence.new(Color3.new(0.458824, 0, 0),Color3.new(0.458824, 0, 0))
ParticleEmitter48.LightInfluence = 1
ParticleEmitter48.Texture = "rbxasset://textures/particles/smoke_main.dds"
ParticleEmitter48.Size = NumberSequence.new(1,0)
ParticleEmitter48.Lifetime = NumberRange.new(0.30000001192093, 0.30000001192093)
ParticleEmitter48.Rate = 30
ParticleEmitter48.SpreadAngle = Vector2.new(-50, 50)
ParticleEmitter48.VelocitySpread = -50
Humanoid49.Parent = Model31
Humanoid49.LeftLeg = Part39
Humanoid49.RightLeg = Part41
Humanoid49.Torso = Part32
Script50.Name = "Animate"
Script50.Parent = Model31
table.insert(cors,sandbox(Script50,function()
function   waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

local Figure = script.Parent
local Torso = waitForChild(Figure, "Torso")
local RightShoulder = waitForChild(Torso, "Right Shoulder")
local LeftShoulder = waitForChild(Torso, "Left Shoulder")
local RightHip = waitForChild(Torso, "Right Hip")
local LeftHip = waitForChild(Torso, "Left Hip")
local Neck = waitForChild(Torso, "Neck")
local Humanoid = waitForChild(Figure, "Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=125750544", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=125750618", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=125749145", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=125750759", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=125750800", weight = 10 } 
			}, 
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=125750867", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=130018893", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=132546839", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=132546884", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=160934142", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934298", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934376", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=160934458", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934530", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934593", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)
		local repeatAnim = stopAllAnimations()
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid)
	local idleFromEmote = (animName == "idle" and emoteNames[currentAnim] ~= nil)
	if (animName ~= currentAnim and not idleFromEmote) then		 
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
	end
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)
		local repeatAnim = stopToolAnimations()
		playToolAnimation(repeatAnim, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid)
	if (animName ~= toolAnimName) then		 
		
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		-- load it to the humanoid; get AnimationTrack
		toolAnimTrack = humanoid:LoadAnimation(anim)
		 
		-- play the animation
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName

		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed>0.01 then
		playAnimation("walk", 0.1, Humanoid)
		pose = "Running"
	else
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed>0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		stopAllAnimations()
		moveSit()
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool then
	
		animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- main program

local runService = game:service("RunService");

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent~=nil do
	local _, time = wait(0.1)
	move(time)
end



end))
StringValue51.Name = "climb"
StringValue51.Parent = Script50
Animation52.Name = "ClimbAnim"
Animation52.Parent = StringValue51
Animation52.AnimationId = "http://www.roblox.com/asset/?id=125750800"
StringValue53.Name = "fall"
StringValue53.Parent = Script50
Animation54.Name = "FallAnim"
Animation54.Parent = StringValue53
Animation54.AnimationId = "http://www.roblox.com/asset/?id=125750759"
StringValue55.Name = "idle"
StringValue55.Parent = Script50
Animation56.Name = "Animation1"
Animation56.Parent = StringValue55
Animation56.AnimationId = "http://www.roblox.com/asset/?id=125750544"
NumberValue57.Name = "Weight"
NumberValue57.Parent = Animation56
NumberValue57.Value = 9
Animation58.Name = "Animation2"
Animation58.Parent = StringValue55
Animation58.AnimationId = "http://www.roblox.com/asset/?id=125750618"
NumberValue59.Name = "Weight"
NumberValue59.Parent = Animation58
NumberValue59.Value = 1
StringValue60.Name = "jump"
StringValue60.Parent = Script50
Animation61.Name = "JumpAnim"
Animation61.Parent = StringValue60
Animation61.AnimationId = "http://www.roblox.com/asset/?id=125750702"
StringValue62.Name = "run"
StringValue62.Parent = Script50
Animation63.Name = "RunAnim"
Animation63.Parent = StringValue62
Animation63.AnimationId = "http://www.roblox.com/asset/?id=125749145"
StringValue64.Name = "toolnone"
StringValue64.Parent = Script50
Animation65.Name = "ToolNoneAnim"
Animation65.Parent = StringValue64
Animation65.AnimationId = "http://www.roblox.com/asset/?id=125750867"
StringValue66.Name = "walk"
StringValue66.Parent = Script50
Animation67.Name = "WalkAnim"
Animation67.Parent = StringValue66
Animation67.AnimationId = "http://www.roblox.com/asset/?id=125749145"
ObjectValue68.Name = "owner"
ObjectValue68.Parent = Model31
Script69.Parent = Model31
table.insert(cors,sandbox(Script69,function()
local me = script.Parent
local owner = me.owner.Value
function dmg(hit)
	if hit.Parent~=nil and hit.Parent~=owner then
		if hit.Parent:findFirstChildOfClass("Humanoid") then
			hit.Parent:findFirstChildOfClass("Humanoid").Health = hit.Parent:findFirstChildOfClass("Humanoid").Health - 40
			if hit.Parent:FindFirstChildOfClass("Humanoid").Health<1 then
				for i,v in pairs(hit.Parent:GetChildren()) do
					if v:IsA("BasePart") then
						v.BrickColor = BrickColor.new('Maroon')
						v.Material = 'Glass'
						v.Transparency = .5
					end
				end
			end
		end
	end
end
function find()
	for i,v in pairs(workspace:GetChildren()) do
		if v~=me and v~=owner then
			if v:FindFirstChild("Head") then
				if v:FindFirstChildOfClass("Humanoid") then
					if (me.Head.Position-v.Head.Position).magnitude<100 and v:FindFirstChildOfClass("Humanoid").Health>0 then
						return v
					end
				end
			end
		end
	end
end
me.Humanoid.Died:Connect(function()
	me:Destroy()
end)
for i,v in pairs(me:GetChildren()) do
	if v:IsA("BasePart") then
		v.Touched:Connect(function(hit)dmg(hit)end)
	end
end
game:GetService("RunService").Stepped:Connect(function()
	local target = find()
	if target ~= nil then
		local h = target.Head
		me.Humanoid:MoveTo(h.Position)
	end
end)
end))
LocalScript70.Parent = Script1
table.insert(cors,sandbox(LocalScript70,function()
-- lag switch by tollepuxis
local plr = game:GetService("Players").LocalPlayer
local mouse = plr:GetMouse()


mouse.KeyDown:Connect(function(k)
	k=k:lower()
	if k=="k" then
		script.Parent.Toggle:FireServer()
	end
end)

end))
LocalScript70.Disabled = true
RemoteEvent71.Name = "Toggle"
RemoteEvent71.Parent = Script1
ParticleEmitter72.Name = "punch"
ParticleEmitter72.Parent = Script1
ParticleEmitter72.Speed = NumberRange.new(30, 30)
ParticleEmitter72.Color = ColorSequence.new(Color3.new(0.2, 0.788235, 1),Color3.new(0.2, 0.788235, 1))
ParticleEmitter72.Enabled = false
ParticleEmitter72.LightEmission = 0.60000002384186
ParticleEmitter72.LightInfluence = 1
ParticleEmitter72.Transparency = NumberSequence.new(0,1)
ParticleEmitter72.Size = NumberSequence.new(0.20000000298023,0.20000000298023)
ParticleEmitter72.Acceleration = Vector3.new(0, -10, 0)
ParticleEmitter72.EmissionDirection = Enum.NormalId.Back
ParticleEmitter72.Lifetime = NumberRange.new(0.10000000149012, 0.89999997615814)
ParticleEmitter72.Rate = 300
ParticleEmitter72.SpreadAngle = Vector2.new(-120, 120)
ParticleEmitter72.VelocitySpread = -120
MeshPart73.Name = "Ring"
MeshPart73.Parent = Script1
MeshPart73.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart73.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart73.Size = Vector3.new(1, 1, 0.100000001)
MeshPart73.Material = Enum.Material.Neon
MeshPart74.Name = "skull"
MeshPart74.Parent = Script1
MeshPart74.CFrame = CFrame.new(-9.49124241, 600.00116, 14.7572317, 1, 0, 0, 0, 1, 0, 0, 0, 1)
MeshPart74.Position = Vector3.new(-9.49124241, 600.00116, 14.7572317)
MeshPart74.Color = Color3.new(1, 0, 0)
MeshPart74.Transparency = 0.5
MeshPart74.Size = Vector3.new(1, 1, 1)
MeshPart74.BrickColor = BrickColor.new("Really red")
MeshPart74.Material = Enum.Material.Glass
MeshPart74.brickColor = BrickColor.new("Really red")
ScreenGui75.Name = "CGui"
ScreenGui75.Parent = Script1
ScreenGui75.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Frame76.Parent = ScreenGui75
Frame76.Position = UDim2.new(0, 0, 0.5, 0)
Frame76.Size = UDim2.new(1, 0, 0.200000003, 0)
Frame76.BackgroundColor = BrickColor.new("Really black")
Frame76.BackgroundColor3 = Color3.new(0, 0, 0)
Frame76.BackgroundTransparency = 0.5
Frame76.BorderSizePixel = 0
Frame77.Name = "f1"
Frame77.Parent = Frame76
Frame77.Position = UDim2.new(0.0346715339, 0, 0.498839885, 0)
Frame77.Rotation = 30
Frame77.Size = UDim2.new(0, 50, 0, 50)
Frame77.AnchorPoint = Vector2.new(0.5, 0.5)
Frame77.BackgroundColor = BrickColor.new("Crimson")
Frame77.BackgroundColor3 = Color3.new(0.772549, 0, 0)
Frame77.BackgroundTransparency = 0.5
Frame77.BorderColor = BrickColor.new("Lime green")
Frame77.BorderColor3 = Color3.new(0, 1, 0)
Frame77.BorderSizePixel = 2
LocalScript78.Name = "appear"
LocalScript78.Parent = Frame76
table.insert(cors,sandbox(LocalScript78,function()

game:GetService("RunService").RenderStepped:Connect(function()
	script.Parent.f1.Rotation = script.Parent.f1.Rotation + 5
	script.Parent.f2.Rotation = script.Parent.f2.Rotation - 5
end)
end))
Frame79.Name = "f2"
Frame79.Parent = Frame76
Frame79.Position = UDim2.new(0.0346715339, 0, 0.498839885, 0)
Frame79.Rotation = -30
Frame79.Size = UDim2.new(0, 25, 0, 25)
Frame79.AnchorPoint = Vector2.new(0.5, 0.5)
Frame79.BackgroundColor = BrickColor.new("Black metallic")
Frame79.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Frame79.BackgroundTransparency = 0.5
Frame79.BorderSizePixel = 0
TextLabel80.Name = "chit"
TextLabel80.Parent = Frame76
TextLabel80.Position = UDim2.new(0.165000007, 0, 0, 0)
TextLabel80.Size = UDim2.new(1, 0, 1, 0)
TextLabel80.BackgroundColor = BrickColor.new("Institutional white")
TextLabel80.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel80.BackgroundTransparency = 1
TextLabel80.Font = Enum.Font.Code
TextLabel80.FontSize = Enum.FontSize.Size28
TextLabel80.Text = "..."
TextLabel80.TextColor = BrickColor.new("Institutional white")
TextLabel80.TextColor3 = Color3.new(1, 1, 1)
TextLabel80.TextSize = 25
TextLabel80.TextWrap = true
TextLabel80.TextWrapped = true
TextLabel80.TextXAlignment = Enum.TextXAlignment.Left
TextLabel81.Name = "mode"
TextLabel81.Parent = Frame76
TextLabel81.Position = UDim2.new(0, 0, -0.38283062, 0)
TextLabel81.Size = UDim2.new(0, 161, 0, 33)
TextLabel81.BackgroundColor = BrickColor.new("Institutional white")
TextLabel81.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel81.BackgroundTransparency = 1
TextLabel81.Font = Enum.Font.Code
TextLabel81.FontSize = Enum.FontSize.Size28
TextLabel81.Text = "Angel"
TextLabel81.TextColor = BrickColor.new("Institutional white")
TextLabel81.TextColor3 = Color3.new(1, 1, 1)
TextLabel81.TextSize = 25
TextLabel81.TextWrap = true
TextLabel81.TextWrapped = true
TextLabel81.TextXAlignment = Enum.TextXAlignment.Left
RemoteFunction82.Name = "Mouse"
RemoteFunction82.Parent = Script1
ModuleScript83.Name = "RbxUtility"
ModuleScript83.Parent = Script1
table.insert(cors,sandbox(ModuleScript83,function()
local t = {}

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------JSON Functions Begin----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

 --JSON Encoder and Parser for Lua 5.1
 --
 --Copyright 2007 Shaun Brown  (http://www.chipmunkav.com)
 --All Rights Reserved.
 
 --Permission is hereby granted, free of charge, to any person 
 --obtaining a copy of this software to deal in the Software without 
 --restriction, including without limitation the rights to use, 
 --copy, modify, merge, publish, distribute, sublicense, and/or 
 --sell copies of the Software, and to permit persons to whom the 
 --Software is furnished to do so, subject to the following conditions:
 
 --The above copyright notice and this permission notice shall be 
 --included in all copies or substantial portions of the Software.
 --If you find this software useful please give www.chipmunkav.com a mention.

 --THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 --EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 --OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 --IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
 --ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 --CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 --CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
local string = string
local math = math
local table = table
local error = error
local tonumber = tonumber
local tostring = tostring
local type = type
local setmetatable = setmetatable
local pairs = pairs
local ipairs = ipairs
local assert = assert


local StringBuilder = {
	buffer = {}
}

function StringBuilder:New()
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.buffer = {}
	return o
end

function StringBuilder:Append(s)
	self.buffer[#self.buffer+1] = s
end

function StringBuilder:ToString()
	return table.concat(self.buffer)
end

local JsonWriter = {
	backslashes = {
		['\b'] = "\\b",
		['\t'] = "\\t",	
		['\n'] = "\\n", 
		['\f'] = "\\f",
		['\r'] = "\\r", 
		['"']  = "\\\"", 
		['\\'] = "\\\\", 
		['/']  = "\\/"
	}
}

function JsonWriter:New()
	local o = {}
	o.writer = StringBuilder:New()
	setmetatable(o, self)
	self.__index = self
	return o
end

function JsonWriter:Append(s)
	self.writer:Append(s)
end

function JsonWriter:ToString()
	return self.writer:ToString()
end

function JsonWriter:Write(o)
	local t = type(o)
	if t == "nil" then
		self:WriteNil()
	elseif t == "boolean" then
		self:WriteString(o)
	elseif t == "number" then
		self:WriteString(o)
	elseif t == "string" then
		self:ParseString(o)
	elseif t == "table" then
		self:WriteTable(o)
	elseif t == "function" then
		self:WriteFunction(o)
	elseif t == "thread" then
		self:WriteError(o)
	elseif t == "userdata" then
		self:WriteError(o)
	end
end

function JsonWriter:WriteNil()
	self:Append("null")
end

function JsonWriter:WriteString(o)
	self:Append(tostring(o))
end

function JsonWriter:ParseString(s)
	self:Append('"')
	self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
		local c = self.backslashes[n]
		if c then return c end
		return string.format("\\u%.4X", string.byte(n))
	end))
	self:Append('"')
end

function JsonWriter:IsArray(t)
	local count = 0
	local isindex = function(k) 
		if type(k) == "number" and k > 0 then
			if math.floor(k) == k then
				return true
			end
		end
		return false
	end
	for k,v in pairs(t) do
		if not isindex(k) then
			return false, '{', '}'
		else
			count = math.max(count, k)
		end
	end
	return true, '[', ']', count
end

function JsonWriter:WriteTable(t)
	local ba, st, et, n = self:IsArray(t)
	self:Append(st)	
	if ba then		
		for i = 1, n do
			self:Write(t[i])
			if i < n then
				self:Append(',')
			end
		end
	else
		local first = true;
		for k, v in pairs(t) do
			if not first then
				self:Append(',')
			end
			first = false;			
			self:ParseString(k)
			self:Append(':')
			self:Write(v)			
		end
	end
	self:Append(et)
end

function JsonWriter:WriteError(o)
	error(string.format(
		"Encoding of %s unsupported", 
		tostring(o)))
end

function JsonWriter:WriteFunction(o)
	if o == Null then 
		self:WriteNil()
	else
		self:WriteError(o)
	end
end

local StringReader = {
	s = "",
	i = 0
}

function StringReader:New(s)
	local o = {}
	setmetatable(o, self)
	self.__index = self
	o.s = s or o.s
	return o	
end

function StringReader:Peek()
	local i = self.i + 1
	if i <= #self.s then
		return string.sub(self.s, i, i)
	end
	return nil
end

function StringReader:Next()
	self.i = self.i+1
	if self.i <= #self.s then
		return string.sub(self.s, self.i, self.i)
	end
	return nil
end

function StringReader:All()
	return self.s
end

local JsonReader = {
	escapes = {
		['t'] = '\t',
		['n'] = '\n',
		['f'] = '\f',
		['r'] = '\r',
		['b'] = '\b',
	}
}

function JsonReader:New(s)
	local o = {}
	o.reader = StringReader:New(s)
	setmetatable(o, self)
	self.__index = self
	return o;
end

function JsonReader:Read()
	self:SkipWhiteSpace()
	local peek = self:Peek()
	if peek == nil then
		error(string.format(
			"Nil string: '%s'", 
			self:All()))
	elseif peek == '{' then
		return self:ReadObject()
	elseif peek == '[' then
		return self:ReadArray()
	elseif peek == '"' then
		return self:ReadString()
	elseif string.find(peek, "[%+%-%d]") then
		return self:ReadNumber()
	elseif peek == 't' then
		return self:ReadTrue()
	elseif peek == 'f' then
		return self:ReadFalse()
	elseif peek == 'n' then
		return self:ReadNull()
	elseif peek == '/' then
		self:ReadComment()
		return self:Read()
	else
		return nil
	end
end
		
function JsonReader:ReadTrue()
	self:TestReservedWord{'t','r','u','e'}
	return true
end

function JsonReader:ReadFalse()
	self:TestReservedWord{'f','a','l','s','e'}
	return false
end

function JsonReader:ReadNull()
	self:TestReservedWord{'n','u','l','l'}
	return nil
end

function JsonReader:TestReservedWord(t)
	for i, v in ipairs(t) do
		if self:Next() ~= v then
			 error(string.format(
				"Error reading '%s': %s", 
				table.concat(t), 
				self:All()))
		end
	end
end

function JsonReader:ReadNumber()
        local result = self:Next()
        local peek = self:Peek()
        while peek ~= nil and string.find(
		peek, 
		"[%+%-%d%.eE]") do
            result = result .. self:Next()
            peek = self:Peek()
	end
	result = tonumber(result)
	if result == nil then
	        error(string.format(
			"Invalid number: '%s'", 
			result))
	else
		return result
	end
end

function JsonReader:ReadString()
	local result = ""
	assert(self:Next() == '"')
        while self:Peek() ~= '"' do
		local ch = self:Next()
		if ch == '\\' then
			ch = self:Next()
			if self.escapes[ch] then
				ch = self.escapes[ch]
			end
		end
                result = result .. ch
	end
        assert(self:Next() == '"')
	local fromunicode = function(m)
		return string.char(tonumber(m, 16))
	end
	return string.gsub(
		result, 
		"u%x%x(%x%x)", 
		fromunicode)
end

function JsonReader:ReadComment()
        assert(self:Next() == '/')
        local second = self:Next()
        if second == '/' then
            self:ReadSingleLineComment()
        elseif second == '*' then
            self:ReadBlockComment()
        else
            error(string.format(
		"Invalid comment: %s", 
		self:All()))
	end
end

function JsonReader:ReadBlockComment()
	local done = false
	while not done do
		local ch = self:Next()		
		if ch == '*' and self:Peek() == '/' then
			done = true
                end
		if not done and 
			ch == '/' and 
			self:Peek() == "*" then
                    error(string.format(
			"Invalid comment: %s, '/*' illegal.",  
			self:All()))
		end
	end
	self:Next()
end

function JsonReader:ReadSingleLineComment()
	local ch = self:Next()
	while ch ~= '\r' and ch ~= '\n' do
		ch = self:Next()
	end
end

function JsonReader:ReadArray()
	local result = {}
	assert(self:Next() == '[')
	local done = false
	if self:Peek() == ']' then
		done = true;
	end
	while not done do
		local item = self:Read()
		result[#result+1] = item
		self:SkipWhiteSpace()
		if self:Peek() == ']' then
			done = true
		end
		if not done then
			local ch = self:Next()
			if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' due to: '%s'", 
					self:All(), ch))
			end
		end
	end
	assert(']' == self:Next())
	return result
end

function JsonReader:ReadObject()
	local result = {}
	assert(self:Next() == '{')
	local done = false
	if self:Peek() == '}' then
		done = true
	end
	while not done do
		local key = self:Read()
		if type(key) ~= "string" then
			error(string.format(
				"Invalid non-string object key: %s", 
				key))
		end
		self:SkipWhiteSpace()
		local ch = self:Next()
		if ch ~= ':' then
			error(string.format(
				"Invalid object: '%s' due to: '%s'", 
				self:All(), 
				ch))
		end
		self:SkipWhiteSpace()
		local val = self:Read()
		result[key] = val
		self:SkipWhiteSpace()
		if self:Peek() == '}' then
			done = true
		end
		if not done then
			ch = self:Next()
                	if ch ~= ',' then
				error(string.format(
					"Invalid array: '%s' near: '%s'", 
					self:All(), 
					ch))
			end
		end
	end
	assert(self:Next() == "}")
	return result
end

function JsonReader:SkipWhiteSpace()
	local p = self:Peek()
	while p ~= nil and string.find(p, "[%s/]") do
		if p == '/' then
			self:ReadComment()
		else
			self:Next()
		end
		p = self:Peek()
	end
end

function JsonReader:Peek()
	return self.reader:Peek()
end

function JsonReader:Next()
	return self.reader:Next()
end

function JsonReader:All()
	return self.reader:All()
end

function Encode(o)
	local writer = JsonWriter:New()
	writer:Write(o)
	return writer:ToString()
end

function Decode(s)
	local reader = JsonReader:New(s)
	return reader:Read()
end

function Null()
	return Null
end
-------------------- End JSON Parser ------------------------

t.DecodeJSON = function(jsonString)
	pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

	if type(jsonString) == "string" then
		return Decode(jsonString)
	end
	print("RbxUtil.DecodeJSON expects string argument!")
	return nil
end

t.EncodeJSON = function(jsonTable)
	pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
	return Encode(jsonTable)
end








------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--makes a wedge at location x, y, z
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
--returns true if made a wedge, false if the cell remains a block
t.MakeWedge = function(x, y, z, defaultmaterial)
	return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
end

t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
	local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
	if not terrain then return end

	assert(regionToSelect)
	assert(color)

	if not type(regionToSelect) == "Region3" then
		error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
	end
	if not type(color) == "BrickColor" then
		error("color (second arg), should be of type BrickColor, but is type",type(color))
	end

	-- frequently used terrain calls (speeds up call, no lookup necessary)
	local GetCell = terrain.GetCell
	local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
	local CellCenterToWorld = terrain.CellCenterToWorld
	local emptyMaterial = Enum.CellMaterial.Empty

	-- container for all adornments, passed back to user
	local selectionContainer = Instance.new("Model")
	selectionContainer.Name = "SelectionContainer"
	selectionContainer.Archivable = false
	if selectionParent then
		selectionContainer.Parent = selectionParent
	else
		selectionContainer.Parent = game:GetService("Workspace")
	end

	local updateSelection = nil -- function we return to allow user to update selection
	local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
	local aliveCounter = 0 -- helper for currentKeepAliveTag
	local lastRegion = nil -- used to stop updates that do nothing
	local adornments = {} -- contains all adornments
	local reusableAdorns = {}

	local selectionPart = Instance.new("Part")
	selectionPart.Name = "SelectionPart"
	selectionPart.Transparency = 1
	selectionPart.Anchored = true
	selectionPart.Locked = true
	selectionPart.CanCollide = false
	selectionPart.Size = Vector3.new(4.2,4.2,4.2)

	local selectionBox = Instance.new("SelectionBox")

	-- srs translation from region3 to region3int16
	local function Region3ToRegion3int16(region3)
		local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
		local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

		local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
		local highCell = WorldToCellPreferSolid(terrain, theHighVec)

		local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
		local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

		return Region3int16.new(lowIntVec,highIntVec)
	end

	-- helper function that creates the basis for a selection box
	function createAdornment(theColor)
		local selectionPartClone = nil
		local selectionBoxClone = nil

		if #reusableAdorns > 0 then
			selectionPartClone = reusableAdorns[1]["part"]
			selectionBoxClone = reusableAdorns[1]["box"]
			table.remove(reusableAdorns,1)

			selectionBoxClone.Visible = true
		else
			selectionPartClone = selectionPart:Clone()
			selectionPartClone.Archivable = false

			selectionBoxClone = selectionBox:Clone()
			selectionBoxClone.Archivable = false

			selectionBoxClone.Adornee = selectionPartClone
			selectionBoxClone.Parent = selectionContainer

			selectionBoxClone.Adornee = selectionPartClone

			selectionBoxClone.Parent = selectionContainer
		end
			
		if theColor then
			selectionBoxClone.Color = theColor
		end

		return selectionPartClone, selectionBoxClone
	end

	-- iterates through all current adornments and deletes any that don't have latest tag
	function cleanUpAdornments()
		for cellPos, adornTable in pairs(adornments) do

			if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
				adornTable.SelectionBox.Visible = false
				table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
				adornments[cellPos] = nil
			end
		end
	end

	-- helper function to update tag
	function incrementAliveCounter()
		aliveCounter = aliveCounter + 1
		if aliveCounter > 1000000 then
			aliveCounter = 0
		end
		return aliveCounter
	end

	-- finds full cells in region and adorns each cell with a box, with the argument color
	function adornFullCellsInRegion(region, color)
		local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
		local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

		local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
		local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

		currentKeepAliveTag = incrementAliveCounter()
		for y = cellPosBegin.y, cellPosEnd.y do
			for z = cellPosBegin.z, cellPosEnd.z do
				for x = cellPosBegin.x, cellPosEnd.x do
					local cellMaterial = GetCell(terrain, x, y, z)
					
					if cellMaterial ~= emptyMaterial then
						local cframePos = CellCenterToWorld(terrain, x, y, z)
						local cellPos = Vector3int16.new(x,y,z)

						local updated = false
						for cellPosAdorn, adornTable in pairs(adornments) do
							if cellPosAdorn == cellPos then
								adornTable.KeepAlive = currentKeepAliveTag
								if color then
									adornTable.SelectionBox.Color = color
								end
								updated = true
								break
							end 
						end

						if not updated then
							local selectionPart, selectionBox = createAdornment(color)
							selectionPart.Size = Vector3.new(4,4,4)
							selectionPart.CFrame = CFrame.new(cframePos)
							local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
							adornments[cellPos] = adornTable
						end
					end
				end
			end
		end
		cleanUpAdornments()
	end


	------------------------------------- setup code ------------------------------
	lastRegion = regionToSelect

	if selectEmptyCells then -- use one big selection to represent the area selected
		local selectionPart, selectionBox = createAdornment(color)

		selectionPart.Size = regionToSelect.Size
		selectionPart.CFrame = regionToSelect.CFrame

		adornments.SelectionPart = selectionPart
		adornments.SelectionBox = selectionBox

		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
				 	selectionPart.Size = newRegion.Size
					selectionPart.CFrame = newRegion.CFrame
				end
				if color then
					selectionBox.Color = color
				end
			end
	else -- use individual cell adorns to represent the area selected
		adornFullCellsInRegion(regionToSelect, color)
		updateSelection = 
			function (newRegion, color)
				if newRegion and newRegion ~= lastRegion then
					lastRegion = newRegion
					adornFullCellsInRegion(newRegion, color)
				end
			end

	end

	local destroyFunc = function()
		updateSelection = nil
		if selectionContainer then selectionContainer:Destroy() end
		adornments = nil
	end

	return updateSelection, destroyFunc
end

-----------------------------Terrain Utilities End-----------------------------







------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Signal class begin------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function 
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
	Arguments:   The function to connect to.
	Returns:     A new connection object which can be used to disconnect the connection
	Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
	             the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
	             connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
	             NOT mean that the first will be called before the second as a result of a call to |fire|.

Method :disconnect()
	Arguments:   None
	Returns:     None
	Description: Disconnects all of the functions connected to this signal.

Method :fire( ... )
	Arguments:   Any arguments are accepted
	Returns:     None
	Description: Calls all of the currently connected functions with the given arguments.

Method :wait()
	Arguments:   None
	Returns:     The arguments given to fire
	Description: This call blocks until 
]]

function t.CreateSignal()
	local this = {}

	local mBindableEvent = Instance.new('BindableEvent')
	local mAllCns = {} --all connection objects returned by mBindableEvent::connect

	--main functions
	function this:connect(func)
		if self ~= this then error("connect must be called with `:`, not `.`", 2) end
		if type(func) ~= 'function' then
			error("Argument #1 of connect must be a function, got a "..type(func), 2)
		end
		local cn = mBindableEvent.Event:Connect(func)
		mAllCns[cn] = true
		local pubCn = {}
		function pubCn:disconnect()
			cn:Disconnect()
			mAllCns[cn] = nil
		end
		pubCn.Disconnect = pubCn.disconnect
		
		return pubCn
	end
	
	function this:disconnect()
		if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
		for cn, _ in pairs(mAllCns) do
			cn:Disconnect()
			mAllCns[cn] = nil
		end
	end
	
	function this:wait()
		if self ~= this then error("wait must be called with `:`, not `.`", 2) end
		return mBindableEvent.Event:Wait()
	end
	
	function this:fire(...)
		if self ~= this then error("fire must be called with `:`, not `.`", 2) end
		mBindableEvent:Fire(...)
	end
	
	this.Connect = this.connect
	this.Disconnect = this.disconnect
	this.Wait = this.wait
	this.Fire = this.fire

	return this
end

------------------------------------------------- Sigal class End ------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------Create Function Begins---------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in 
which case it simply creates an object of the given type, or a table argument that may contain several types of data, 
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
      Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
      ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
      |Create| call's body.

2) An integral key mapping to another Instance:
      Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
      parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
      need for temporary variables to store references to those objects.

3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
      The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy 
      for those who really want such a functionality. The name of the event whose name is passed to 
      Create.E( string )

4) A key which is the Create function itself, and a value which is a function
      The function will be run with the argument of the object itself after all other initialization of the object is 
      done by create. This provides a way to do arbitrary things involving the object from withing the create 
      hierarchy. 
      Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
      it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the 
      constructor callback function is possible, it is probably not a good design choice.
      Note: Since the constructor function is called after all other initialization, a Create block cannot have two 
      constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.


Some example usages:

A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
    Name = 'A New model',
    Parent = game.Workspace,
}


An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
 |-ObjectValue
 |  |
 |  `-BoolValueChild
 `-IntValue

local model = Create'Model'{
    Name = 'Model_Container',
    Create'ObjectValue'{
        Create'BoolValue'{
            Name = 'BoolValueChild',
        },
    },
    Create'IntValue'{},
}


An example using the event syntax:

local part = Create'Part'{
    [Create.E'Touched'] = function(part)
        print("I was touched by "..part.Name)
    end,	
}


An example using the general constructor syntax:

local model = Create'Part'{
    [Create] = function(this)
        print("Constructor running!")
        this.Name = GetGlobalFoosAndBars(this)
    end,
}


Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
      any unexpected behavior. EG:
      local partCreatingFunction = Create'Part'
      local part = partCreatingFunction()
]]

--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
--will be created in several steps rather than as a single function declaration.
local function Create_PrivImpl(objectType)
	if type(objectType) ~= 'string' then
		error("Argument of Create must be a string", 2)
	end
	--return the proxy function that gives us the nice Create'string'{data} syntax
	--The first function call is a function call using Lua's single-string-argument syntax
	--The second function call is using Lua's single-table-argument syntax
	--Both can be chained together for the nice effect.
	return function(dat)
		--default to nothing, to handle the no argument given case
		dat = dat or {}

		--make the object to mutate
		local obj = Instance.new(objectType)
		local parent = nil

		--stored constructor function to be called after other initialization
		local ctor = nil

		for k, v in pairs(dat) do
			--add property
			if type(k) == 'string' then
				if k == 'Parent' then
					-- Parent should always be set last, setting the Parent of a new object
					-- immediately makes performance worse for all subsequent property updates.
					parent = v
				else
					obj[k] = v
				end


			--add child
			elseif type(k) == 'number' then
				if type(v) ~= 'userdata' then
					error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
				end
				v.Parent = obj


			--event connect
			elseif type(k) == 'table' and k.__eventname then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
					       got: "..tostring(v), 2)
				end
				obj[k.__eventname]:connect(v)


			--define constructor function
			elseif k == t.Create then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
					       got: "..tostring(v), 2)
				elseif ctor then
					--ctor already exists, only one allowed
					error("Bad entry in Create body: Only one constructor function is allowed", 2)
				end
				ctor = v


			else
				error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
			end
		end

		--apply constructor function if it exists
		if ctor then
			ctor(obj)
		end
		
		if parent then
			obj.Parent = parent
		end

		--return the completed object
		return obj
	end
end

--now, create the functor:
t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
t.Create.E = function(eventName)
	return {__eventname = eventName}
end

-------------------------------------------------Create function End----------------------------------------------------




------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------Documentation Begin-----------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------

t.Help = 
	function(funcNameOrFunc) 
		--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
		if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
			return "Function DecodeJSON.  " ..
			       "Arguments: (string).  " .. 
			       "Side effect: returns a table with all parsed JSON values" 
		end
		if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
			return "Function EncodeJSON.  " ..
			       "Arguments: (table).  " .. 
			       "Side effect: returns a string composed of argument table in JSON data format" 
		end  
		if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
			return "Function MakeWedge. " ..
			       "Arguments: (x, y, z, [default material]). " ..
			       "Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
			       "parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
			       "Returns true if made a wedge, false if the cell remains a block "
		end
		if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
			return "Function SelectTerrainRegion. " ..
			       "Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
			       "Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
			       "(this should be a region3 value). The selection box color is detemined by the color argument " ..
			       "(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
			       "SelectEmptyCells is bool, when true will select all cells in the " ..
			       "region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
			       "arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
			       "Also returns a second function that takes no arguments and destroys the selection"
		end
		if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
			return "Function CreateSignal. "..
			       "Arguments: None. "..
			       "Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
			       "used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
			       "Lua code. "..
			       "Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
			       "For more info you can pass the method name to the Help function, or view the wiki page "..
			       "for this library. EG: Help('Signal:connect')."
		end
		if funcNameOrFunc == "Signal:connect" then
			return "Method Signal:connect. "..
			       "Arguments: (function handler). "..
			       "Return: A connection object which can be used to disconnect the connection to this handler. "..
			       "Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
			       "handler function will be called with the arguments passed to |fire|."
		end
		if funcNameOrFunc == "Signal:wait" then
			return "Method Signal:wait. "..
			       "Arguments: None. "..
			       "Returns: The arguments passed to the next call to |fire|. "..
			       "Description: This call does not return until the next call to |fire| is made, at which point it "..
			       "will return the values which were passed as arguments to that |fire| call."
		end
		if funcNameOrFunc == "Signal:fire" then
			return "Method Signal:fire. "..
			       "Arguments: Any number of arguments of any type. "..
			       "Returns: None. "..
			       "Description: This call will invoke any connected handler functions, and notify any waiting code "..
			       "attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
			       "to handlers are made asynchronously, so this call will return immediately regardless of how long "..
			       "it takes the connected handler functions to complete."
		end
		if funcNameOrFunc == "Signal:disconnect" then
			return "Method Signal:disconnect. "..
			       "Arguments: None. "..
			       "Returns: None. "..
			       "Description: This call disconnects all handlers attacched to this function, note however, it "..
			       "does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
			       "can also be called on the connection object which is returned from Signal:connect to only "..
			       "disconnect a single handler, as opposed to this method, which will disconnect all handlers."
		end
		if funcNameOrFunc == "Create" then
			return "Function Create. "..
			       "Arguments: A table containing information about how to construct a collection of objects. "..
			       "Returns: The constructed objects. "..
			       "Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
			       "is best described via example, please see the wiki page for a description of how to use it."
		end
	end
	
--------------------------------------------Documentation Ends----------------------------------------------------------

return t
end))
ScreenGui84.Name = "ReplicatedEffects"
ScreenGui84.Parent = ModuleScript0
ScreenGui84.ResetOnSpawn = false
ScreenGui84.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
LocalScript85.Name = "ReplicatedEffects"
LocalScript85.Parent = ScreenGui84
table.insert(cors,sandbox(LocalScript85,function()
-- tollepuxis non-laggy replicated effects test
local Effects = Instance.new('Model',workspace)
Effects.Name = 'ClientEffects'
vt=Vector3.new
cf=CFrame.new
angles=CFrame.Angles
it=Instance.new
function swait(num)
	if num == 0 or num == nil then
		game:GetService("RunService").RenderStepped:Wait(0)
	else
		for i=0,num,1 do
			game:GetService("RunService").RenderStepped:Wait(0)
		end
	end
end
function nooutline(part)
        part.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10
    end
function NoOutline(part)
        part.TopSurface,part.BottomSurface,part.LeftSurface,part.RightSurface,part.FrontSurface,part.BackSurface = 10,10,10,10,10,10
    end
 function part(formfactor,parent,material,reflectance,transparency,brickcolor,name,size)
        local fp=it("Part")
        fp.formFactor=formfactor
        fp.Parent=parent
        fp.Reflectance=reflectance
        fp.Transparency=transparency
        fp.CanCollide=false
        fp.Locked=true
        fp.BrickColor=BrickColor.new(tostring(brickcolor))
        fp.Name=name
        fp.Size=size
        fp.Position=Character.Torso.Position
        nooutline(fp)
        fp.Material=material
        fp:BreakJoints()
        return fp
    end
   
    function ppart(formfactor,parent,reflectance,transparency,brickcolor,name,size)
        local fp = it("Part")
        fp.formFactor = formfactor
        fp.Parent = parent
        fp.Reflectance = reflectance
        fp.Transparency = transparency
        fp.CanCollide = false
        fp.Locked=true
        fp.BrickColor = brickcolor
        fp.Name = name
        fp.Size = size
        fp.Position = vt(0,0,0)
        NoOutline(fp)
        fp.Material="Neon"
        fp:BreakJoints()
        return fp
    end
  function wweld(parent,part0,part1,c0)
        local weld=it("Weld")
        weld.Parent=parent 
        weld.Part0=part0
        weld.Part1=part1
        weld.C0=c0
        return weld
    end
   
    function mesh(Mesh,part,meshtype,meshid,offset,scale)
        local mesh=it(Mesh)
        mesh.Parent=part
        if Mesh=="SpecialMesh" then
            mesh.MeshType=meshtype
            mesh.MeshId=meshid
        end
        mesh.Offset=offset
        mesh.Scale=scale
        return mesh
    end
function magicblock(cf,color,x,y,z,x1,y1,z1,del)
	local p = Instance.new('Part',Effects)
	p.CanCollide = false
	p.Anchored = true
	p.Material = 'Neon'
	p.Size = Vector3.new(1,1,1)
	p.CFrame = cf
	p.BrickColor = color
	local msh = Instance.new('BlockMesh', p)
	msh.Scale = Vector3.new(x,y,z)
	spawn(function()
		for i=0,1,del do
			swait()
			msh.Scale = msh.Scale + Vector3.new(x1,y1,z1)
			p.Transparency = i
			p.CFrame = p.CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50,50),math.random(-50,50),math.random(-50,50))
		end
		p:Destroy()
	end)
end


mode = 1
function magicsphere(cf,color,x,y,z,x1,y1,z1,del)
	local p = Instance.new('Part',Effects)
	p.CanCollide = false
	p.Anchored = true
	p.Material = 'Neon'
	p.Size = Vector3.new(1,1,1)
	p.CFrame = cf
	p.BrickColor = color
	local msh = Instance.new('SpecialMesh', p)
	msh.Scale = Vector3.new(x,y,z)
	msh.MeshType = 'Sphere'
	spawn(function()
		for i=0,1,del do
			swait()
			msh.Scale = msh.Scale + Vector3.new(x1,y1,z1)
			p.Transparency = i
		end
		p:Destroy()
	end)
end
function magicring(cf,color,x,y,z,x1,y1,z1,del)
	local p = Instance.new('Part',Effects)
	p.CanCollide = false
	p.Anchored = true
	p.Material = 'Neon'
	p.Size = Vector3.new(1,1,1)
	p.CFrame = cf
	p.BrickColor = color
	local msh = Instance.new('FileMesh', p)
	msh.Scale = Vector3.new(x,y,z)
	msh.MeshId = 'rbxassetid://3270017'
	spawn(function()
		for i=0,1,del do
			swait()
			msh.Scale = msh.Scale + Vector3.new(x1,y1,z1)
			p.Transparency = i
		end
		p:Destroy()
	end)
end
function magicwave(cf,color,x,y,z,x1,y1,z1,del)
	local p = Instance.new('Part',Effects)
	p.CanCollide = false
	p.Anchored = true
	p.Material = 'Neon'
	p.Size = Vector3.new(1,1,1)
	p.CFrame = cf
	p.BrickColor = color
	local msh = Instance.new('FileMesh', p)
	msh.Scale = Vector3.new(x,y,z)
	msh.MeshId = 'rbxassetid://20329976'
	spawn(function()
		for i=0,1,del do
			swait()
			msh.Scale = msh.Scale + Vector3.new(x1,y1,z1)
			p.Transparency = i
		end
		p:Destroy()
	end)
end
function magicwave2(cf,color,x,y,z,x1,y1,z1,del,rotate)
	local p = Instance.new('Part',Effects)
	p.CanCollide = false
	p.Anchored = true
	p.Material = 'Neon'
	p.Size = Vector3.new(1,1,1)
	p.CFrame = cf
	p.BrickColor = color
	local msh = Instance.new('FileMesh', p)
	msh.Scale = Vector3.new(x,y,z)
	msh.MeshId = 'rbxassetid://20329976'
	spawn(function()
		for i=0,1,del do
			swait()
			msh.Scale = msh.Scale + Vector3.new(x1,y1,z1)
			p.CFrame=p.CFrame*angles(0,rotate,0)
			p.Transparency = i
		end
		p:Destroy()
	end)
end

game.ReplicatedStorage.ReplicateEffect.OnClientEvent:Connect(function(eff,cf,color,x,y,z,x1,y1,z1,del,rotate)
	if eff == 'sphere' then
		magicsphere(cf,color,x,y,z,x1,y1,z1,del)
		elseif eff=='block' then
		magicblock(cf,color,x,y,z,x1,y1,z1,del)
		elseif eff=='ring' then
		magicring(cf,color,x,y,z,x1,y1,z1,del)
		elseif eff=='wave1' then
		magicwave(cf,color,x,y,z,x1,y1,z1,del)
		elseif eff=='wave2' then
		magicwave2(cf,color,x,y,z,x1,y1,z1,del,rotate)
	end
end)

local TweenService = game:GetService('TweenService')
function Tween(obj,props,time,easing,direction,repeats,backwards)
    local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
    local tween = TweenService:Create(obj, info, props)
    tween:Play()
end

game.ReplicatedStorage.ReplicateTween.OnClientEvent:Connect(function(obj,props,time,easing,direction,repeats,backwards)
	Tween(obj,props,time,easing,direction,repeats,backwards)
end)

function Effect(data)
	local FX = data.FX or "ResizeFade"
	local Settings = data.Settings
	if FX == "ResizeFade" then
		local prt = ppart("Custom",Effects,0,Settings.StartTransparency,Settings.Color,"Effect",Vector3.new(1,1,1))
		prt.Anchored = true
		prt.CFrame=Settings.StartCFrame
		local msh = mesh(Settings.Mesh, prt, Settings.MeshType, Settings.MeshId, Vector3.new(), Settings.StartSize)
		spawn(function()
			Tween(prt, {Transparency=Settings.EndTransparency,CFrame=Settings.EndCFrame}, Settings.Time, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false)
			Tween(msh, {Scale=Settings.EndSize}, Settings.Time, Enum.EasingStyle.Back, Enum.EasingDirection.Out, 0, false)
			game:GetService("Debris"):AddItem(prt,Settings.Life or 6)
		end)
	end
end

game.ReplicatedStorage.ReplicateSpecialEffect.OnClientEvent:Connect(function(data)
	Effect(data)
end)

Effects.ChildAdded:Connect(function(n)
	if n:isA("BasePart")
	then
		n.CastShadow = false
	end
end)
end))
Folder86.Name = "Remotes"
Folder86.Parent = ModuleScript0
BindableEvent87.Parent = Folder86
RemoteEvent88.Name = "ReplicateEffect"
RemoteEvent88.Parent = Folder86
RemoteEvent89.Name = "ReplicateSpecialEffect"
RemoteEvent89.Parent = Folder86
RemoteEvent90.Name = "ReplicateTween"
RemoteEvent90.Parent = Folder86
RemoteEvent91.Name = "ServerChat"
RemoteEvent91.Parent = Folder86
for i,v in pairs(mas:GetChildren()) do
	v.Parent = workspace
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end

end