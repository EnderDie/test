if game:GetService("RunService"):IsClient() then error("Please run as a server script. Use h/ instead of hl/.") end
print("FE Compatibility: by WaverlyCole & Mokiros")
InternalData = {}
do
	script.Parent = owner.Character
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInput"
	local function NewFakeEvent()
		local Fake = {fakeEvent=true,Connect=function(self,Func)self.Function=Func end}Fake.connect = Fake.Connect
		return Fake
	end
	local Mouse = {Target=nil,Hit=CFrame.new(),KeyUp=NewFakeEvent(),KeyDown=NewFakeEvent(),Button1Up=NewFakeEvent(),Button1Down=NewFakeEvent()}
	local UserInputService = {InputBegan=NewFakeEvent(),InputEnded=NewFakeEvent()}
	local ContextActionService = {Actions={},BindAction = function(self,actionName,Func,touch,...)
		self.Actions[actionName] = Func and {Name=actionName,Function=Func,Keys={...}} or nil
	end};ContextActionService.UnBindAction = ContextActionService.BindAction
	local function TriggerEvent(self,Event,...)
		local Trigger = Mouse[Event]
		if Trigger and Trigger.fakeEvent and Trigger.Function then
			Trigger.Function(...)
		end
	end
	Mouse.TrigEvent = TriggerEvent
	UserInputService.TrigEvent = TriggerEvent
	Event.OnServerEvent:Connect(function(FiredBy,Input)
		if FiredBy.Name ~= owner.Name then end
		if Input.MouseEvent then
			Mouse.Target = Input.Target
			Mouse.Hit = Input.Hit
		else
			local Begin = Input.UserInputState == Enum.UserInputState.Begin
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				return Mouse:TrigEvent(Begin and "Button1Down" or "Button1Up")
			end
			for _,Action in pairs(ContextActionService.Actions) do
				for _,Key in pairs(Action.Keys) do
					if Key==Input.KeyCode then
						Action.Function(Action.Name,Input.UserInputState,Input)
					end
				end
			end
			Mouse:TrigEvent(Begin and "KeyDown" or "KeyUp",Input.KeyCode.Name:lower())
			UserInputService:TrigEvent(Begin and "InputBegan" or "InputEnded",Input,false)
		end
	end)
	InternalData["Mouse"] = Mouse
	InternalData["ContextActionService"] = ContextActionService
	InternalData["UserInputService"] = UserInputService
	Event.Parent = NLS([[
		local Player = owner
		local Event = script:WaitForChild("UserInput")
		local UserInputService = game:GetService("UserInputService")
		local Mouse = Player:GetMouse()
		local Input = function(Input,gameProcessedEvent)
			if gameProcessedEvent then return end
			Event:FireServer({KeyCode=Input.KeyCode,UserInputType=Input.UserInputType,UserInputState=Input.UserInputState})
		end
		UserInputService.InputBegan:Connect(Input)
		UserInputService.InputEnded:Connect(Input)
		local Hit,Target
		while wait(1/30) do
			if Hit ~= Mouse.Hit or Target ~= Mouse.Target then
				Hit,Target = Mouse.Hit,Mouse.Target
				Event:FireServer({["MouseEvent"]=true,["Target"]=Target,["Hit"]=Hit})
			end
		end
	]],owner.Character)
end
RealGame = game;game = setmetatable({},{
	__index = function (self,Index)
		local Sandbox = function (Thing)
			if Thing:IsA("Player") then
				local RealPlayer = Thing
				return setmetatable({},{
					__index = function (self,Index)
						local Type = type(RealPlayer[Index])
						if Type == "function" then
							if Index:lower() == "getmouse" or Index:lower() == "mouse" then
								return function (self)
									return InternalData["Mouse"]
								end
							end
							return function (self,...)
								return RealPlayer[Index](RealPlayer,...)
							end
						else
							if Index == "PlrObj" then
								return RealPlayer
							end
							return RealPlayer[Index]
						end
					end;
					__tostring = function(self)
						return RealPlayer.Name
					end
				})
			end
		end
		if RealGame[Index] then
			local Type = type(RealGame[Index])
			if Type == "function" then
				if Index:lower() == "getservice" or Index:lower() == "service" then
					return function (self,Service)
						if Service:lower() == "players" then
							return setmetatable({},{
								__index = function (self2,Index2)
									local RealService = RealGame:GetService(Service)
									local Type2 = type(Index2)
									if Type2 == "function" then
										return function (self,...)
											return RealService[Index2](RealService,...)
										end
									else
										if Index2:lower() == "localplayer" then
											return Sandbox(owner)
										end
										return RealService[Index2]
									end
								end;
								__tostring = function(self)
									return RealGame:GetService(Service).Name
								end
							})
						elseif Service:lower() == "contextactionservice" then
							return InternalData["ContextActionService"]
						elseif Service:lower() == "contextactionservice" then
							return InternalData["UserInputService"]
						elseif Service:lower() == "runservice" then
							return setmetatable({},{
								__index = function(self2,Index2)
									local RealService = RealGame:GetService(Service)
									local Type2 = type(Index2)
									if Type2 == "function" then
										return function (self,...)
											return RealService[Index2](RealService,...)
										end
									else
										if Index2:lower() == "bindtorenderstep" then
											return function (self,Name,Priority,Function)
												return RealGame:GetService("RunService").Stepped:Connect(Function)
											end
										end
										if Index2:lower() == "renderstepped" then
											return RealService["Stepped"]
										end
										return RealService[Index2]
									end
								end
							})
						else
							return RealGame:GetService(Service)
						end
					end
				end
				return function (self,...)
					return RealGame[Index](RealGame,...)
				end
			else
				if game:GetService(Index) then
					return game:GetService(Index)
				end
				return RealGame[Index]
			end
		else
			return nil
		end
	end
});Game = game;owner = game:GetService("Players").LocalPlayer;script = {}
print("Complete! Running...")


--//Paste script below this line.

local guithingytext = ([[
KnottyEeveez_MegaCreations.11.2019
Copyright(KnottyEeveez-2019)
This isn't a glitcher anymore. It's beyond glitcher
Project Name: Articulacy



Everyone deserves a second chance. Even superzombie and Poison. But those who don't deserve a second chance. I will always be filled with extreme hatred
and anger for those who disobey life and law. I hate them and I'm absolutely sure who I hate and for what reason.

Motivators:
The Glitcher Simulator Community - Even through tough times they've always made me feel better about myself
Derpz/Jake - After being called a skid many times I think he's one of the most supportive people I've met.
superzombie900 - Even though he may be called a skid in everyone's eyes. In my eyes he's someone I cherish as a friend.
Salvo_Starly - Nah just kidding he hated me lol
Poison_Resistance/ItzPoison - Despite having bad times actually cared for me in the hardest times.
Dreamer - They're cool. Taught me how to NOT be a espresso depresso.
Avix_G - Keeping the community a respectful place.
Aero - Doesn't steal my stuff. Automatically cool

And finally. You. The person using this script. By using this script you are supporting me by basically telling me that you'll
actually have a look at the script instead of judging it by it's ugly cover.

Well.. Enough of my backstory and more about the script.

Credit to Derpz/Jake for Cassidy's Backstory and letting me join in on DG:TR's backstory.

The start of the Articulacy Era... Their name... Was Cassidy.
They were a silent person. Always disregarding and ignoring people when they ask someone, And unfortunately, Also bullied in the past by many for such reason.
Eventually, Cassidy almost had enough. They were about to snap. They couldn't take it any longer.
So what they done... Was have a look around for their brother-in-law, Jake's ideas.
They went around and asked what projects they were doing and if they could possibly borrow any.
Jake was working on a core which replaces the heart and gives you infinite powers to customise to your liking.
Cassidy was amazed, And asked if there could be one made for her.
Jake agreed, But under 1 condition.
Do not, And I repeat... DO NOT use this for abuse or the pain of innocent others.
Cassidy was in a rush, And didn't know what to do... So they just agreed and as soon as they got the blueprints from Jake, Instantly got to work.
Cassidy inserted it into her chest around where her heart was, Like the blueprint told to. They felt... Odd. All of a sudden, They realised something brush against them on their back.
It... Was wings.
They knew something had finally changed. And they can finally take back what they want... And be unstoppable...

This... Is...

A R T I C U L A C Y

	
CREDITS:	
GodzPlaysRB/Wonder/KnottyEeveez - Owner/Scripter
Aero - Co-Owner/Developer
UnfairGaming1 - Scripter/Developer
Derpz/Jake - Contributed Predator's Animation/Morphing System
Chat GUI originally by Salvo_Starly and modified by MrMafiaHat
Credit where credit is due. Any code from other scripters.
Leanop - CR Template

EXTRA INFORMATION:
Wielder: Cassidy Nakamura
Mood: Revengeful

rbxassetid://916843842 pitch to 3 lol

Allies:
Cercilla - Ruin Emphasis, Ruin XI and Ruin XII
Nevada - Heart Shattered

Enemies/Rivals: -- In priority
Jake_Davies(Derpz) - Derpz Glitcher
Aprins - Reality Glitcher

------MODES------
# - WIP
* - Finished
/ - Animation Needed
A - Attack Needed
E - Effects Needed
R - Refinement Need
-----------------
Page 1 Modes:
A   Stigmatist - Madness (Originated from Eth v1)
A   Manipulate - Control (Originated from Spec v4)
A   Fraternity - Fate (Originated from Ruin XI)
*  Ignition - Fire/Lava (Originated from Eth v1)
A   Galactica - Space/Starry (Originated from Ruin XI)
*   U-K-E - Love/Affection (v7 Remake) -- Attack making in progress
*   Hostility - Anger (Originated from Eth v1)
A   DESOLATE - Isolation
A   Predator - Attraction/Horror
A   Disinterestedness - Justice/Law
A   隠された - Hidden/Obscured 
Page 2 Modes:
A   VOYAGER - Explorer
*   Tranquillity - Peace/Relaxation (Originated from Spec v9) -- Doesn't hurt people
A   Deception - Decieve (Originated from Spec v4)
AE/ Transfixation - Paralyzed
AE/ Jucidian - Angelistic (Originated from Spec v5)
*   SYNOPHASIS - Relaxing (Originated from the Ethereal Rewrite)
---FUTURE MODES--- In priority

---TO DO LIST--- In priority
Add a questionable attack to U-K-E

--- NOTES --- Developer Notes
Derpz - Fixed the .Create function being deprecated in later releases.


]])
warn'Articulacy loaded.. Bring the madness.'

wait(1)
local kan = Instance.new("Sound",char)
kan.Volume = 1.15
kan.TimePosition = 0
kan.PlaybackSpeed = 1.01
kan.Pitch = 1.01
kan.SoundId = "rbxassetid://1327600769"
kan.Name = "Articulacy"
kan.Looped = true
local Player = game:GetService("Players"):GetPlayerFromCharacter(script.Parent)
local plr = Player
local mouse = Player:GetMouse()
local entergui = script.EthLoad
entergui.Parent = plr.PlayerGui
entergui.Main.Scroll.Text.Text = guithingytext
--{0.251, 0},{0.27, 0}
entergui.Main:TweenPosition(UDim2.new(0.251, 0,0.27, 0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,2)
local nipsexist = false
local armorexist = true
entergui.Main.Options.Option2.Opti1.MouseButton1Click:Connect(function()
if(armorexist==true)then
armorexist = false
entergui.Main.Options.Option2.Opti1.Image="http://www.roblox.com/asset/?id=53252054"
elseif(armorexist==false)then
armorexist = true
entergui.Main.Options.Option2.Opti1.Image="http://www.roblox.com/asset/?id=149260637"
end
end)
entergui.Main.Options.Option1.Opti1.MouseButton1Click:Connect(function()
if(nipsexist==true)then
nipsexist = false
entergui.Main.Options.Option1.Opti1.Image="http://www.roblox.com/asset/?id=53252054"
elseif(nipsexist==false)then
nipsexist = true
entergui.Main.Options.Option1.Opti1.Image="http://www.roblox.com/asset/?id=149260637"
end
end)
entergui.Main.Run.MouseButton1Click:Connect(function()
	kan:Play()
entergui.Main:TweenPosition(UDim2.new(-1, 0,0.27, 0),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.7)
local Hue = 0
mouse = mouse
char = plr.Character
Character = char
hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
Camera = cam
local CamInterrupt = false
local TwoD = false
local TargetInfo = {nil, nil}
cam.CameraType = "Custom"
t = char.Torso
h = char.Head
ra = char["Right Arm"]
la = char["Left Arm"]
rl = char["Right Leg"]
ll = char["Left Leg"]
tors = char.Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
hed = char.Head
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
radian = math.rad
random = math.random
Vec3 = Vector3.new
Inst = Instance.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
cf = CFrame.new
cos = math.cos
rad = math.rad
sin = math.sin
radm = math.random
huge = math.huge
tan = math.tan
abs = math.abs
switch = 1
local freemodelflame = script.Flame
freemodelflame.Enabled = true
function TweenAnimate(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
local infos=TweenInfo.new(time,Enum.EasingStyle[easingstyle],Enum.EasingDirection[easingdirection],repet,reverse,deelay)
local tween=game:GetService("TweenService"):Create(object,infos,Aniim)
tween:Play()
return tween
end

local visu = {}
local stupidbguvis = {}
local stupidbguvis2 = {}
local Mode = 1
cooldown = 0
level = 0
levelnum = 0
local attackmultiplier = 1
local DefenceHealthMax = 8000
local DefenceHealth = 8000
local MAINRUINCOLOR = BrickColor.new("Really red").Color
local MAINRUINCOLOR2 = BrickColor.new("Maroon").Color
barrier1 = 0
barrier2 = 0
local ShieldYes = true
barrier3 = 0
sine1 = 0
sine2 = 0
sine3 = 0
rotatio = 0
local EffectsF = script.Effects
local stupidgui = script.yes
stupidgui.Parent = plr.PlayerGui
local MLT = script.ML
MLT.Parent = plr.PlayerGui
switchb = false
local BarrierEnabled = true

local AttachmentHolder = script.AttachmentH
local HealEff = AttachmentHolder.Torso
HealEff.Parent = tors
local Refit = AttachmentHolder.Refit
Refit.Parent = tors


local Fire1 = script.Flame:Clone()
Fire1.Parent = rarm

local Fire2 = script.Flame:Clone()
Fire2.Parent = larm

local Star1 = script.Blue:Clone()
Star1.Parent = rarm


local Star2 = script.Blue:Clone()
Star2.Parent = larm

local Gui = script.Articulacy
Gui.Parent = plr.PlayerGui
Gui.Enabled = true

for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
if v.Name == "Line" or v.Name == "Line2" then
v.BackgroundColor3 = MAINRUINCOLOR2
end
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR
end
if v.Name == "Vis" and v:IsA("Frame") then
table.insert(visu,v)
end
end

local Booleans = {
  CamFollow = false,
  GyroUse = true
}

function lerp(object, newCFrame, alpha)
  return object:lerp(newCFrame, alpha)
end

local Directer = Inst("BodyGyro", root)
Directer.MaxTorque = Vec3(0, 0, 0)
Directer.P = 600000
local CPart = Inst("Part")
CPart.Anchored = true
CPart.CanCollide = false
CPart.Locked = true
CPart.Transparency = 1

local rainbowmode = false
local chaosmode = false

local ORGID = 0
local ORVOL = 1.15
local ORPIT = 1.01

local currentThemePlaying = kan.SoundId
local currentPitch = kan.Pitch
local currentVol = kan.Volume
function newTheme(ID,timepos,pitch,vol)
local kanz = kan
--kanz:Stop()
kanz.Volume = vol
--kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "Articulacy"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
--kanz:Play()
--spawn(function()
--wait(0.05)
--end)
end


function newThemeCust(ID,timepos,pitch,vol)
local kanz = kan
kanz:Stop()
kanz.Volume = vol
kanz.TimePosition = timepos
kanz.PlaybackSpeed = pitch
kanz.Pitch = pitch
kanz.SoundId = ID
kanz.Name = "Articulacy"
kanz.Looped = true
currentThemePlaying = kanz.SoundId
currentVol = kanz.Volume
currentPitch = kanz.Pitch
kanz:Play()
spawn(function()
wait(0.05)
end)
end

local mutedtog = false
local bilguit = script.bgu
bilguit.Adornee = hed
bilguit.Parent = hed
bilguit.Enabled = true
bilguit.Name = "ModeName"
local modet = bilguit.Namer
modet.TextScaled = true
modet.TextTransparency = 0
modet.BackgroundTransparency = 1 
modet.TextTransparency = 0
modet.TextStrokeTransparency = 0
modet.Font = "Gotham"
modet.TextStrokeColor3 = Color3.new(1,0,0)
modet.TextColor3 = Color3.new(0.5,0,0)
modet.Text = "Stigmatist"
local fx1 = bilguit.FX1
local fx2 = bilguit.FX2

function CameraEnshaking(Length,Intensity)
spawn(function()
      local intensity = 1*Intensity
      local rotM = 0.01*Intensity
for i = 0, Length, 0.1 do
swait()
intensity = intensity - 0.05*Intensity/Length
rotM = rotM - 0.0005*Intensity/Length
      hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
      cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
end
Humanoid.CameraOffset = Vec3(0, 0, 0)
end)
end
CamShake=function(Part,Distan,Power,Times) 
local de=Part.Position
for i,v in pairs(workspace:children()) do
 if v:IsA("Model") and v:findFirstChild("Humanoid") then
for _,c in pairs(v:children()) do
if c.ClassName=="Part" and (c.Position - de).magnitude < Distan then
local Noob=v.Humanoid
if Noob~=nil then
spawn(function()
FV = Instance.new("BoolValue", Noob)
FV.Name = "CameraShake"
for ShakeNum=1,Times do
swait()
local ef=Power
  if ef>=1 then
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef),math.random(-ef,ef),math.random(-ef,ef))
  else
   ef=Power*10
   Humanoid.CameraOffset = Vector3.new(math.random(-ef,ef)/10,math.random(-ef,ef)/10,math.random(-ef,ef)/10)
  end	
end
Humanoid.CameraOffset = Vector3.new(0,0,0)
FV:Destroy()
end)
CameraShake(Times, Power, Noob)
end
end
end
end
end
end

    local NewInstance = function(instance,parent,properties)
        local inst = Instance.new(instance,parent)
        if(properties)then
            for i,v in next, properties do
                pcall(function() inst[i] = v end)
            end
        end
        return inst;
    end
FXFolder=script.Effects
function CamShake2(who,data)
    coroutine.wrap(function()
        if(FXFolder:FindFirstChild'CamShake')then
            local cam = FXFolder.CamShake:Clone()
            cam:WaitForChild'intensity'.Value = data.Intensity or 5
            cam:WaitForChild'duration'.Value = data.Duration or 5
            cam:WaitForChild'speed'.Value = data.Speed or 10;
             if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
            cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
            cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
            cam:WaitForChild'startdist'.Value = data.DropDist or 25;
            cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;
            
            cam.Parent = who
            wait()
            cam.Disabled = false
            wait(3)
            cam:Destroy()
        end
    end)()
end

function CamShakeAll2(data)
    for _,v in next, game:service'Players':players() do
        CamShake2(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
    end
end

--[[
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=60; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=80; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
]]--

function chatfunc(text,color,typet,font,timeex)
local chat = coroutine.wrap(function()
if Character:FindFirstChild("TalkingBillBoard")~= nil then
Character:FindFirstChild("TalkingBillBoard"):destroy()
end
local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.Size = UDim2.new(0,100,0,40)
naeeym2.StudsOffset = Vector3.new(0,3,0)
naeeym2.Adornee = Character.Head
naeeym2.Name = "TalkingBillBoard"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.BorderSizePixel = 0
tecks2.Text = ""
tecks2.Font = font
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = color
tecks2.TextStrokeColor3 = Color3.new(0,0,0)
tecks2.Size = UDim2.new(1,0,0.5,0)
local tecks3 = Instance.new("TextLabel",naeeym2)
tecks3.BackgroundTransparency = 1
tecks3.BorderSizePixel = 0
tecks3.Text = ""
tecks3.Font = font
tecks3.TextSize = 30
tecks3.TextStrokeTransparency = 0
if typet == "Inverted" then
tecks3.TextColor3 = Color3.new(0,0,0)
tecks3.TextStrokeColor3 = color
elseif typet == "Normal" then
tecks3.TextColor3 = color
tecks3.TextStrokeColor3 = Color3.new(0,0,0)
end
tecks3.Size = UDim2.new(1,0,0.5,0)
spawn(function()
while true do
swait(1)
if chaosmode == true then
tecks2.TextColor3 = BrickColor.random().Color
tecks3.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
for i = 0, 74*timeex do
swait()
tecks2.Text = text
tecks3.Text = text
end
local randomrot = math.random(1,2)
if randomrot == 1 then
for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
elseif randomrot == 2 then
	for i = 1, 50 do
swait()
tecks2.Text = text
tecks3.Text = text
tecks2.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks2.TextTransparency = tecks2.TextTransparency + .04
tecks3.TextStrokeTransparency = tecks2.TextStrokeTransparency +.04
tecks3.TextTransparency = tecks2.TextTransparency + .04
end
end
if toggleTag == false then
end
naeeym2:Destroy()
end)
chat()
end

function bosschatfunc(text,color1,color2,delay)
	for _,v in next, game:service'Players':players() do
		coroutine.wrap(function()
			if(EffectsF:FindFirstChild'BossChat' and v.Character)then
				local cha = EffectsF.BossChat:Clone()
				cha.Color1.Value=color1
				cha.Color2.Value=color2
				cha.Text.Value=text
				cha.Ghghghghgh.Value=delay
				cha.Mode.Value=Mode
				cha.ModeName.Value=modet.Text
				cha.Music.Value=kan
				cha.Parent=v.Character
				swait()
				cha.Disabled = false
				game:service'Debris':AddItem(cha,(delay/60)*4)
			end
		end)()
	end
end

function newbosschatfunc(text,color,watval)
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
spawn(function()
if v.PlayerGui:FindFirstChild("Dialog")~= nil then
v.PlayerGui:FindFirstChild("Dialog"):destroy()
end
local scrg = Instance.new("ScreenGui",v.PlayerGui)
CFuncs["EchoSound"].Create("rbxassetid://525200869", scrg, 0.5, 1,0,10,0.1,0.25,1)
scrg.Name = "Dialog"
local txtlb = Instance.new("TextLabel",scrg)
txtlb.Text = ""
txtlb.Font = "Bodoni"
txtlb.TextColor3 = Color3.new(0,0,0)
txtlb.TextStrokeTransparency = 0
txtlb.BackgroundTransparency = 0.75
txtlb.BackgroundColor3 = Color3.new(0,0,0)
txtlb.TextStrokeColor3 = color
txtlb.TextScaled = true
txtlb.Size = UDim2.new(1,0,0.25,0)
txtlb.TextXAlignment = "Left"
txtlb.Position = UDim2.new(0,0,0.75 + 1,0)
local txtlb2 = Instance.new("TextLabel",scrg)
txtlb2.Text = "???:"
txtlb2.Font = "Arcade"
txtlb2.TextColor3 = Color3.new(0,0,0)
txtlb2.TextStrokeTransparency = 0
txtlb2.BackgroundTransparency = 1
txtlb2.TextStrokeColor3 = color
txtlb2.TextSize = 40
txtlb2.Size = UDim2.new(1,0,0.25,0)
txtlb2.TextXAlignment = "Left"
txtlb2.Position = UDim2.new(0,0,1,0)
local fvalen = 0.55
local fval = -0.49
spawn(function()
while true do
swait()
if chaosmode == true then
txtlb.Rotation = math.random(-1,1)
txtlb2.Rotation = math.random(-1,1)
txtlb.Position = txtlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb.TextStrokeColor3 = BrickColor.random().Color
txtlb2.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
spawn(function()
while true do
swait()
if scrg.Parent ~= nil then
	fvalen = fvalen - 0.0001
elseif scrg.Parent == nil then
break
end
end
end)
local flol = 1.75
local flil = 1.6
spawn(function()
	for i = 0, 9 do
		swait()
		fval = fval + 0.05
		flol = flol - 0.1
		flil = flil - 0.1
		txtlb.Text = ""
		txtlb.Position = UDim2.new(0,0,flol,0)
		txtlb2.Position = UDim2.new(0,0,flil,0)
	end
	txtlb.Text = text
wait(watval)
local valinc = 0
for i = 0, 99 do
swait()
valinc = valinc + 0.0001
flol = flol + valinc
flil = flil + valinc
txtlb.Rotation = txtlb.Rotation + valinc*20
txtlb2.Rotation = txtlb2.Rotation - valinc*50
txtlb.Position = UDim2.new(0,0,flol,0)
txtlb2.Position = UDim2.new(0,0,flil,0)
txtlb.TextStrokeTransparency = txtlb.TextStrokeTransparency + 0.01
txtlb.TextTransparency = txtlb.TextTransparency + 0.01
txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
txtlb.BackgroundTransparency = txtlb.BackgroundTransparency + 0.0025
end
scrg:Destroy()
end)
end)
end
end


local Create = require(game:GetService("ReplicatedStorage"):WaitForChild("LoadLibrary"):WaitForChild("RbxUtility")).Create

CFuncs = {	
	["Part"] = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Mesh"] = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end;
	};
	
	["Weld"] = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld"){
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1,
			}
			return Weld
		end;
	};

	["Sound"] = {
		Create = function(id, par, vol, pit) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end)
		end;
	};

	["TimeSound"] = {
		Create = function(id, par, vol, pit, timepos) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
                                        Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
                                        TimePosition = timepos,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 10)
			end)
		end;
	};
		["EchoSound"] = {
		Create = function(id, par, vol, pit, timepos,delays,echodelay,fedb,dryl) 
			spawn(function()
				local Sas = Create("Sound"){
					Volume = vol,
                    Name = math.random(0,2552525),
					Pitch = pit or 1,
					SoundId = id,
                    TimePosition = timepos,
					Parent = par or workspace,
				}
				local E = Create("EchoSoundEffect"){
					Delay = echodelay,
                    Name = "Echo",
					Feedback = fedb,
                    DryLevel = dryl,
					Parent = Sas,
				}
				wait() 
				Sas:play() 
				game:GetService("Debris"):AddItem(Sas, delays)
			end)
		end;
	};

["LongSound"] = {
		Create = function(id, par, vol, pit) 
			spawn(function()
				local S = Create("Sound"){
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace,
				}
				wait() 
				S:play() 
				game:GetService("Debris"):AddItem(S, 60)
			end)
		end;
	};
	
	["ParticleEmitter"] = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter"){
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread,
			}
			return fp
		end;
	};

	CreateTemplate = {
	
	};
}



New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
local halocolor = BrickColor.new("Pastel light blue")
local halocolor2 = BrickColor.new("Cool yellow")
local starcolor = BrickColor.new("Bright yellow")
local lunacolor = BrickColor.new("Navy blue")
local lunacolor2 = BrickColor.new("Bright blue")
local wepcolor = BrickColor.new("Really black")
local maincolor = BrickColor.new("Really black")
local m = Instance.new("Model",char)
local m2 = Instance.new("Model",char)
local m3 = Instance.new("Model",char)
local mw1 = Instance.new("Model",char)
local mw2 = Instance.new("Model",char)
local effectz = Instance.new("Folder",char)
effectz.Name = "Effects"

gui = function(GuiType, parent, text, backtrans, backcol, pos, size)
  local gui = it(GuiType)
  gui.Parent = parent
  gui.Text = text
  gui.BackgroundTransparency = backtrans
  gui.BackgroundColor3 = backcol
  gui.SizeConstraint = "RelativeXY"
  gui.TextXAlignment = "Center"
  gui.TextYAlignment = "Center"
  gui.Position = pos
  gui.Size = size
  gui.Font = "SourceSans"
  gui.FontSize = "Size14"
  gui.TextWrapped = false
  gui.TextStrokeTransparency = 0
  gui.TextColor = BrickColor.new("White")
  return gui
end
--------------------------- GUI STUFF
local basgui = it("GuiMain")
basgui.Parent = plr.PlayerGui
basgui.Name = "VISgui"
local fullscreenz = it("Frame")
fullscreenz.Parent = basgui
fullscreenz.BackgroundColor3 = Color3.new(255, 255, 255)
fullscreenz.BackgroundTransparency = 1
fullscreenz.BorderColor3 = Color3.new(17, 17, 17)
fullscreenz.Size = UDim2.new(1, 0, 1, 0)
fullscreenz.Position = UDim2.new(0, 0, 0, 0)
local vis1 = Instance.new("Frame",fullscreenz)
vis1.BackgroundTransparency = 1
vis1.BorderSizePixel = 0
vis1.BackgroundColor3 = MAINRUINCOLOR
vis1.Size = UDim2.new(0,0.04,0,0)
vis1.Position = UDim2.new(0,0,1,0)

local extrawingmod1 = Instance.new("Model",char)
local extrawingmod2 = Instance.new("Model",char)

function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


--------------
--------------
local sorb = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb,rarm,sorb,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local sorb2 = CreateParta(m,1,1,"SmoothPlastic",BrickColor.random())
CreateWeld(sorb2,larm,sorb2,0,1,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local xae = Instance.new("Part",char)
xae.Transparency = 1
xae.Anchored = true
xae.CanCollide = false

local handlex = CreateParta(mw1,1,1,"Neon",maincolor)
CreateMesh(handlex,"Brick",0,0,0)
local handlexweld = CreateWeld(handlex,tors,handlex,0,0,-0.5,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local handle = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local handleweld = CreateWeld(handle,handlex,handle,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local handler = CreateParta(mw2,1,1,"Neon",maincolor)
CreateMesh(handler,"Brick",0,0,0)
local rotweld = CreateWeld(handler,handlex,handler,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ringgu = script.Core:Clone()
ringgu.Parent = mw2
for i,v in pairs(ringgu:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
CreateWeld(ringgu.Main,handler,ringgu.Main,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local halohh = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local haloweld = CreateWeld(halohh,hed,halohh,0,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))


local Hall = script.Halo:Clone()
Hall.Parent = mw2
for i,v in pairs(Hall:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
end
end
CreateWeld(Hall.Main,halohh,Hall.Main,0,-1.5,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local gauntneon = {}
if armorexist == true then
local RuinXII = script.RuinXII:Clone()
RuinXII.Parent = rarm
for i,v in pairs(RuinXII:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Color == Color3.fromRGB(0, 165, 140) then
table.insert(gauntneon,v)
v.Color = BrickColor.new("Really red").Color
end
	end
end
CreateWeld(RuinXII.Weld,rarm,RuinXII.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local RuinXII2 = script.RuinXII:Clone()
RuinXII2.Parent = larm
for i,v in pairs(RuinXII2:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Color == Color3.fromRGB(0, 165, 140) then
table.insert(gauntneon,v)
v.Color = BrickColor.new("Really red").Color
end
	end
end
CreateWeld(RuinXII2.Weld,larm,RuinXII2.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local RuinXII3 = script.RightBinder:Clone()
RuinXII3.Parent = rleg
for i,v in pairs(RuinXII3:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Color == Color3.fromRGB(0, 165, 140) then
table.insert(gauntneon,v)
v.Color = BrickColor.new("Really red").Color
end
	end
end
CreateWeld(RuinXII3.Weld,rleg,RuinXII3.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local RuinXII4 = script.LeftBinder:Clone()
RuinXII4.Parent = lleg
for i,v in pairs(RuinXII4:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Color == Color3.fromRGB(0, 165, 140) then
table.insert(gauntneon,v)
v.Color = BrickColor.new("Really red").Color
end
	end
end
CreateWeld(RuinXII4.Weld,lleg,RuinXII4.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))
end

local RuinXIIT = script.TorsoA:Clone()
RuinXIIT.Parent = tors
for i,v in pairs(RuinXIIT:GetChildren())do
	if v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
v.Anchored = false
if v.Color == Color3.fromRGB(0, 165, 140) then
table.insert(gauntneon,v)
v.Color = BrickColor.new("Really red").Color
end
if v.Name == "Nips" then
v.Transparency = 1
end
	end
end
CreateWeld(RuinXIIT.Weld,tors,RuinXIIT.Weld,0,0,0,math.rad(0),math.rad(0),math.rad(0),0,0,0,math.rad(0),math.rad(0),math.rad(0))


------
local ringatt = ringgu.Main.Attachment

local lwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing1weld = CreateWeld(lwing1,handle,lwing1,1,0,0,math.rad(5),math.rad(0),math.rad(12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt 
CreateWeld(ae.Main,lwing1,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing2weld = CreateWeld(lwing2,handle,lwing2,1,1,0,math.rad(10),math.rad(0),math.rad(25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,lwing2,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local lwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local lwing3weld = CreateWeld(lwing3,handle,lwing3,1,2,0,math.rad(15),math.rad(0),math.rad(37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw1
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,lwing3,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

-- Right wing.

local rwing1 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing1weld = CreateWeld(rwing1,handle,rwing1,-1,0,0,math.rad(5),math.rad(0),math.rad(-12.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing1,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing2 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing2weld = CreateWeld(rwing2,handle,rwing2,-1,1,0,math.rad(10),math.rad(0),math.rad(-25),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing2,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local rwing3 = CreateParta(m,1,1,"Neon",maincolor)
CreateMesh(handle,"Brick",0.5,0.5,0.5)
local rwing3weld = CreateWeld(rwing3,handle,rwing3,-1,2,0,math.rad(15),math.rad(0),math.rad(-37.5),0,0,0,math.rad(0),math.rad(0),math.rad(0))

local ae = script.Wing:Clone()
ae.Parent = mw2
for i,v in pairs(ae:GetDescendants())do
if v:IsA("BasePart")then
	v.Anchored = false
end
end
ae.Main.Beam.Attachment1 = ringatt
CreateWeld(ae.Main,rwing3,ae.Main,0,0,-1.75,math.rad(0),math.rad(0),math.rad(-0),0,0,0,math.rad(0),math.rad(0),math.rad(0))



function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end

Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LW=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RW=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 

Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

function warnedpeople(text,represfont,color,color2)
CFuncs["Sound"].Create("rbxassetid://534859368", char, 2.5,1)
CFuncs["Sound"].Create("rbxassetid://963718869", char, 1,1)
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
spawn(function()
if v.PlayerGui:FindFirstChild("Spinny")~= nil then
v.PlayerGui:FindFirstChild("Spinny"):destroy()
end
local scrg = Instance.new("ScreenGui",v.PlayerGui)
scrg.Name = "Spinny"
local frm = Instance.new("Frame",scrg)
frm.BackgroundTransparency = 0.25
frm.BackgroundColor3 = color
frm.BorderSizePixel = 0
frm.Rotation = 45
frm.Size = UDim2.new(3,0,0,100)
frm.Position = UDim2.new(-4,0,0,0)
local frm2 = frm:Clone()
frm2.Parent = scrg
frm2.BackgroundColor3 = color2
frm2.Position = UDim2.new(-4.05,0,0,0)
local imlb = Instance.new("ImageLabel",scrg)
imlb.BackgroundTransparency = 1
imlb.BackgroundColor3 = Color3.new(0,0,0)
imlb.Image = "rbxassetid://2344851144"
imlb.Size = UDim2.new(0,750,0,750)
imlb.ImageColor3 = color2
imlb.ImageTransparency = 0.25
imlb.Position = UDim2.new(-2.5,0,-2.5,0)
local imlb2 = imlb:Clone()
imlb2.Image = "rbxassetid://2325939897"
imlb2.Size = UDim2.new(1,0,1,0)
imlb2.ImageColor3 = color
imlb2.ImageTransparency = 0
imlb2.Position = UDim2.new(0,0,0,0)
local imlb3 = imlb:Clone()
imlb3.Image = "rbxassetid://2344830904"
imlb3.Size = UDim2.new(1,0,1,0)
imlb3.ImageColor3 = color2
imlb3.ImageTransparency = 0
imlb3.Position = UDim2.new(0,0,0,0)
local imlb4 = imlb:Clone()
imlb4.Image = "rbxassetid://2344870656"
imlb4.Size = UDim2.new(1,0,1,0)
imlb4.ImageColor3 = Color3.new(1,1,1)
imlb4.ImageTransparency = 0
imlb4.Position = UDim2.new(0,0,0,0)
imlb2.Parent = imlb
imlb3.Parent = imlb
imlb4.Parent = imlb
local txtlb2 = Instance.new("TextLabel",imlb)
txtlb2.Text = text
txtlb2.Font = represfont
txtlb2.TextColor3 = color
txtlb2.TextStrokeTransparency = 0
txtlb2.BackgroundTransparency = 1
txtlb2.TextStrokeColor3 = color2
txtlb2.TextScaled = true
txtlb2.Size = UDim2.new(1,0,1,0)
txtlb2.Position = UDim2.new(0,0,0,0)
local fvalen = 0.55
local fval = -0.49
spawn(function()
while true do
swait()
if chaosmode == true then
txtlb2.Rotation = math.random(-1,1)
imlb.Position = imlb.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
txtlb2.Position = txtlb2.Position + UDim2.new(0,math.random(-1,1)/5,0,math.random(-1,1)/5)
imlb.ImageColor3 = BrickColor.random().Color
txtlb2.TextStrokeColor3 = BrickColor.random().Color
end
end
end)
spawn(function()
while true do
swait()
if scrg.Parent ~= nil then
	fvalen = fvalen - 0.0001
elseif scrg.Parent == nil then
break
end
end
end)
local flol = -5
local flil = 1.6
spawn(function()
	for i = 0, 49 do
		swait()
		flol = flol + 0.125
		flil = flil - 0.1
		frm.Size = frm.Size + UDim2.new(0.1,0,0,0)
		frm.Rotation = frm.Rotation - 0.25
		frm2.Size = frm2.Size + UDim2.new(0.1,0,0,0)
		frm2.Rotation = frm.Rotation + 0.325
		imlb3.Rotation = imlb3.Rotation - 10
		imlb2.Rotation = imlb.Rotation + 7.5
		imlb.Rotation = imlb.Rotation + 5
		txtlb2.Rotation = txtlb2.Rotation - 5.125
		imlb.Position = imlb.Position + UDim2.new(0.05125,0,0.04775,0)
	end
	for i = 0, 99 do
		swait()
		fval = fval + 0.05
		flol = flol + 0.005
		frm.Size = frm.Size + UDim2.new(0.005,0,0,0)
		frm.Rotation = frm.Rotation - 0.075
		frm2.Size = frm2.Size + UDim2.new(0.005,0,0,0)
		frm2.Rotation = frm2.Rotation + 0.125
		imlb3.Rotation = imlb3.Rotation - 2
		imlb2.Rotation = imlb.Rotation + 1.5
		imlb.Rotation = imlb.Rotation + 1
		txtlb2.Rotation = txtlb2.Rotation - 1.125
		imlb.Position = imlb.Position + UDim2.new(0.0015,0,0.00075,0)
	end
local valinc = 0
local vinc2 = 1
for i = 0, 99 do
swait()
vinc2 = vinc2 + 0.25
valinc = valinc + 0.0001
flol = flol + valinc
flil = flil + valinc
txtlb2.Rotation = txtlb2.Rotation - 1.125*vinc2
imlb3.Rotation = imlb3.Rotation - 2*vinc2
imlb.Rotation = imlb.Rotation + 1*vinc2
imlb.Position = imlb.Position + UDim2.new(0.0015*vinc2,0,0.0005*vinc2,0)
frm.Size = frm.Size + UDim2.new(0.005*vinc2,0,0,0)
frm.Rotation = frm.Rotation + 0.1*vinc2
frm2.Size = frm2.Size + UDim2.new(0.005*vinc2,0,0,0)
frm2.Rotation = frm2.Rotation + 0.225*vinc2
frm2.BackgroundTransparency = frm2.BackgroundTransparency + 0.0075
frm.BackgroundTransparency = frm.BackgroundTransparency + 0.0075
imlb.ImageTransparency = imlb.ImageTransparency + 0.005
imlb2.ImageTransparency = imlb2.ImageTransparency + 0.01
imlb3.ImageTransparency = imlb3.ImageTransparency + 0.01
imlb4.ImageTransparency = imlb4.ImageTransparency + 0.01
txtlb2.TextStrokeTransparency = txtlb2.TextStrokeTransparency + 0.01
txtlb2.TextTransparency = txtlb2.TextTransparency + 0.01
end
scrg:Destroy()
end)
end)
end
end



--save shoulders 
--[[RSH, LSH=nil, nil 
--welds 
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil ]]--
-- 
RW.Name="Right Shoulder"
RW.Part0=char.Torso 
RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
RW.C1=cf(0, 0.5, 0) 
RW.Part1=char["Right Arm"] 
RW.Parent=char.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=char.Torso 
LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
LW.C1=cf(0, 0.5, 0) 
LW.Part1=char["Left Arm"] 
LW.Parent=char.Torso

local donum=0
 

function part(formfactor,parent,reflectance,transparency,brickcolor,name,size)
local fp=it("Part")
fp.formFactor=formfactor 
fp.Parent=parent
fp.Reflectance=reflectance
fp.Transparency=transparency
fp.CanCollide=false 
fp.Locked=true
fp.BrickColor=brickcolor
fp.Name=name
fp.Size=size
fp.Position=Torso.Position 
NoOutline(fp)
fp.Material="SmoothPlastic"
fp:BreakJoints()
return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
local mesh=it(Mesh) 
mesh.Parent=part
if Mesh=="SpecialMesh" then
mesh.MeshType=meshtype
if meshid~="nil" then
mesh.MeshId="http://www.roblox.com/asset/?id="..meshid
end
end
mesh.Offset=offset
mesh.Scale=scale
return mesh
end
 
function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end
 
local Color1=Torso.BrickColor

local bodvel=Instance.new("BodyVelocity")
local bg=Instance.new("BodyGyro")

--------- SazEreno's Artificial HB --------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")
Frame_Speed = 1 / 60
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

------------------
function swait(num)
if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, num do
			ArtificialHB.Event:wait()
		end
	end
end
-------- RAINBOW LEAVE IT TO ME
local r = 255
local g = 0
local b = 0
spawn(function()
while wait() do
	for i = 0, 254/5 do
		swait()
		g = g + 5
	end
	for i = 0, 254/5 do
		swait()
		r = r - 5
	end
	for i = 0, 254/5 do
		swait()
		b = b + 5
	end
	for i = 0, 254/5 do
		swait()
		g = g - 5
	end
	for i = 0, 254/5 do
		swait()
		r = r + 5
	end
	for i = 0, 254/5 do
		swait()
		b = b - 5
	end
end
end)
 
 
so = function(id,par,vol,pit) 
spawn(function()
local sou = Instance.new("Sound",par or workspace)
sou.Volume=vol
sou.Pitch=pit or 1
sou.SoundId=id
swait() 
sou:play() 
game:GetService("Debris"):AddItem(sou,6)
end)
end
 
function clerp(a,b,t) 
local qa = {QuaternionFromCFrame(a)}
local qb = {QuaternionFromCFrame(b)} 
local ax, ay, az = a.x, a.y, a.z 
local bx, by, bz = b.x, b.y, b.z
local _t = 1-t
return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 
 
function QuaternionFromCFrame(cf) 
local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
local trace = m00 + m11 + m22 
if trace > 0 then 
local s = math.sqrt(1 + trace) 
local recip = 0.5/s 
return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
else 
local i = 0 
if m11 > m00 then
i = 1
end
if m22 > (i == 0 and m00 or m11) then 
i = 2 
end 
if i == 0 then 
local s = math.sqrt(m00-m11-m22+1) 
local recip = 0.5/s 
return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
elseif i == 1 then 
local s = math.sqrt(m11-m22-m00+1) 
local recip = 0.5/s 
return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
elseif i == 2 then 
local s = math.sqrt(m22-m00-m11+1) 
local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
end 
end 
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w) 
local xs, ys, zs = x + x, y + y, z + z 
local wx, wy, wz = w*xs, w*ys, w*zs 
local xx = x*xs 
local xy = x*ys 
local xz = x*zs 
local yy = y*ys 
local yz = y*zs 
local zz = z*zs 
return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end
 
function QuaternionSlerp(a, b, t) 
local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
local startInterp, finishInterp; 
if cosTheta >= 0.0001 then 
if (1 - cosTheta) > 0.0001 then 
local theta = math.acos(cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((1-t)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta  
else 
startInterp = 1-t 
finishInterp = t 
end 
else 
if (1+cosTheta) > 0.0001 then 
local theta = math.acos(-cosTheta) 
local invSinTheta = 1/math.sin(theta) 
startInterp = math.sin((t-1)*theta)*invSinTheta 
finishInterp = math.sin(t*theta)*invSinTheta 
else 
startInterp = t-1 
finishInterp = t 
end 
end 
return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

local function CFrameFromTopBack(at, top, back)
local right = top:Cross(back)
return CFrame.new(at.x, at.y, at.z,
right.x, top.x, back.x,
right.y, top.y, back.y,
right.z, top.z, back.z)
end

function Triangle(a, b, c)
local edg1 = (c-a):Dot((b-a).unit)
local edg2 = (a-b):Dot((c-b).unit)
local edg3 = (b-c):Dot((a-c).unit)
if edg1 <= (b-a).magnitude and edg1 >= 0 then
a, b, c = a, b, c
elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
a, b, c = b, c, a
elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
a, b, c = c, a, b
else
assert(false, "unreachable")
end
 
local len1 = (c-a):Dot((b-a).unit)
local len2 = (b-a).magnitude - len1
local width = (a + (b-a).unit*len1 - c).magnitude
 
local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
 
local list = {}
 
if len1 > 0.01 then
local w1 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w1,5)
w1.Material = "SmoothPlastic"
w1.FormFactor = 'Custom'
w1.BrickColor = BrickColor.new("Really red")
w1.Transparency = 0
w1.Reflectance = 0
w1.Material = "SmoothPlastic"
w1.CanCollide = false
local l1 = Instance.new("PointLight",w1)
l1.Color = Color3.new(170,0,0)
NoOutline(w1)
local sz = Vector3.new(0.2, width, len1)
w1.Size = sz
local sp = Instance.new("SpecialMesh",w1)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
w1:BreakJoints()
w1.Anchored = true
w1.Parent = workspace
w1.Transparency = 0.7
table.insert(Effects,{w1,"Disappear",.01})
w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
table.insert(list,w1)
end
 
if len2 > 0.01 then
local w2 = Instance.new('WedgePart', m)
game:GetService("Debris"):AddItem(w2,5)
w2.Material = "SmoothPlastic"
w2.FormFactor = 'Custom'
w2.BrickColor = BrickColor.new("Really red")
w2.Transparency = 0
w2.Reflectance = 0
w2.Material = "SmoothPlastic"
w2.CanCollide = false
local l2 = Instance.new("PointLight",w2)
l2.Color = Color3.new(170,0,0)
NoOutline(w2)
local sz = Vector3.new(0.2, width, len2)
w2.Size = sz
local sp = Instance.new("SpecialMesh",w2)
sp.MeshType = "Wedge"
sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
w2:BreakJoints()
w2.Anchored = true
w2.Parent = workspace
w2.Transparency = 0.7
table.insert(Effects,{w2,"Disappear",.01})
w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
table.insert(list,w2)
end
return unpack(list)
end
 

function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
  if hit.Parent == nil then
    return
  end
  local h = hit.Parent:FindFirstChildOfClass("Humanoid")
  for _, v in pairs(hit.Parent:children()) do
    if v:IsA("Humanoid") then
      h = v
    end
  end
  if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Head") ~= nil then
    if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
      return
    end
    local c = Create("ObjectValue")({
      Name = "creator",
      Value = Player,
      Parent = h
    })
    game:GetService("Debris"):AddItem(c, 0.5)
    if HitSound ~= nil and HitPitch ~= nil then
      CFuncs.Sound.Create(HitSound, hit, 1, HitPitch)
    end
    local Damage = math.random(minim, maxim)
    local blocked = false
    local block = hit.Parent:findFirstChild("Block")
    if block ~= nil and block.className == "IntValue" and block.Value > 0 then
      blocked = true
      block.Value = block.Value - 1
      print(block.Value)
    end
    if blocked == false then
      HitHealth = h.Health
      h.MaxHealth = 100
      h.Health = h.Health - Damage
      if HitHealth ~= h.Health and HitHealth ~= 0 and 0 >= h.Health and h.Parent.Name ~= "Hologram" then
        print("gained kill")
        dmg(h.Parent)
levelnum = levelnum + 50
      end
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    else
      h.Health = h.Health - Damage / 2
      ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), Damage, .03, Part.BrickColor.Color)
    end
    if Type == "Knockdown" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(1)
        HHumanoid.PlatformStand = false
      end), hum)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)
    elseif Type == "Normal" then
      local vp = Create("BodyVelocity")({
        P = 500,
        maxForce = Vector3.new(math.huge, 0, math.huge),
        velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
      })
      if knockback > 0 then
        vp.Parent = hit.Parent.Head
      end
      game:GetService("Debris"):AddItem(vp, 0.5)
    elseif Type == "Up" then
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Leech" then
      local hum = hit.Parent.Humanoid
      if hum ~= nil then
        for i = 0, 2 do
          Effects.Sphere.Create(BrickColor.new("Bright red"), hit.Parent.Torso.CFrame * cn(0, 0, 0) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
        end
        Humanoid.Health = Humanoid.Health + 10
      end
    elseif Type == "UpKnock" then
      local hum = hit.Parent.Humanoid
      hum.PlatformStand = true
      if hum ~= nil then
        hitr = true
      end
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(5)
        HHumanoid.PlatformStand = false
        hitr = false
      end), hum)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 0.5)
      local bodyVelocity = Create("BodyVelocity")({
        velocity = Vector3.new(0, 20, 0),
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodyVelocity, 1)
    elseif Type == "Snare" then
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Slashnare" then
      Effects.Block.Create(BrickColor.new("Pastel Blue"), hit.Parent.Torso.CFrame * cn(0, 0, 0), 15*4, 15*4, 15*4, 3*4, 3*4, 3*4, 0.07)
      for i = 1, math.random(4, 5) do
        Effects.Sphere.Create(BrickColor.new("Teal"), hit.Parent.Torso.CFrame * cn(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5)) * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 15, 1, 0, 5, 0, 0.02)
      end
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
	elseif Type == "Burn" then

      local humss = hit.Parent:findFirstChildOfClass("Humanoid")
      humss.PlatformStand = true
      coroutine.resume(coroutine.create(function(HHumanoid)
        swait(60)
        HHumanoid.PlatformStand = false
      end), humss)
      local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
      local bodvol = Create("BodyVelocity")({
        velocity = angle * knockback,
        P = 5000,
        maxForce = Vector3.new(8000, 8000, 8000),
        Parent = hit
      })
      local rl = Create("BodyAngularVelocity")({
        P = 3000,
        maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
        angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
        Parent = hit
      })
      game:GetService("Debris"):AddItem(bodvol, 0.5)
      game:GetService("Debris"):AddItem(rl, 0.5)

	coroutine.resume(coroutine.create(function()
		if hit.Parent:findFirstChild("Torso")then
			local hitoor=hit.Parent:findFirstChild("Torso")
		local da = freemodelflame:Clone()
		da.Parent = hitoor
		da.Enabled = true
				local BURNBABYBURN = Create("Sound"){
					Volume = 1,
                    Name = "asdawdwadadw",
					Pitch = 1.2,
					Looped = true,
					SoundId = "rbxassetid://1601946639",
					Parent = hitoor,
				}
				BURNBABYBURN:play()
		for i=1, 150 do
		swait(5)
		humss.Health = humss.Health - .4
		end
		da.Enabled = false
		BURNBABYBURN:Remove()
 	     game:GetService("Debris"):AddItem(da, 2)
		end
	end))
	
    elseif Type == "Spike" then
      CreateBigIceSword(hit.Parent.Torso.CFrame)
      local bp = Create("BodyPosition")({
        P = 2000,
        D = 100,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      game:GetService("Debris"):AddItem(bp, 1)
    elseif Type == "Freeze" then
      local BodPos = Create("BodyPosition")({
        P = 50000,
        D = 1000,
        maxForce = Vector3.new(math.huge, math.huge, math.huge),
        position = hit.Parent.Torso.Position,
        Parent = hit.Parent.Torso
      })
      local BodGy = Create("BodyGyro")({
        maxTorque = Vector3.new(400000, 400000, 400000) * math.huge,
        P = 20000,
        Parent = hit.Parent.Torso,
        cframe = hit.Parent.Torso.CFrame
      })
      hit.Parent.Torso.Anchored = true
      coroutine.resume(coroutine.create(function(Part)
        swait(1.5)
        Part.Anchored = false
      end), hit.Parent.Torso)
      game:GetService("Debris"):AddItem(BodPos, 3)
      game:GetService("Debris"):AddItem(BodGy, 3)
    end
    local debounce = Create("BoolValue")({
      Name = "DebounceHit",
      Parent = hit.Parent,
      Value = true
    })
    game:GetService("Debris"):AddItem(debounce, Delay)
    c = Instance.new("ObjectValue")
    c.Name = "creator"
    c.Value = Player
    c.Parent = h
    game:GetService("Debris"):AddItem(c, 0.5)
  end
end
function ShowDamage(Pos, Text, Time, Color)
coroutine.resume(coroutine.create(function()
  local Rate = 0.03333333333333333
  local Pos = Pos or Vector3.new(0, 0, 0)
  local Text = Text or ""
  local Color = Color or Color3.new(1, 0, 1)
  local EffectPart = CreatePart(Character, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
  EffectPart.Anchored = true
  EffectPart.CFrame = CFrame.new(Pos)
  local BillboardGui = Create("BillboardGui")({
    Size = UDim2.new(6, 0, 6, 0),
    Adornee = EffectPart,
    Parent = EffectPart,
	AlwaysOnTop=true,
	Active=true
  })
  local TextLabel = Create("TextLabel")({
    BackgroundTransparency = 1,
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(1, 0, 1, 0),
    Text = Text,
    TextColor3 = MAINRUINCOLOR,
   	TextStrokeColor3 = MAINRUINCOLOR2,
	TextStrokeTransparency=0,
    TextScaled = true,
    Font = Enum.Font.Bodoni,
    Parent = BillboardGui,
	ZIndex=4,
  })

local aaa=math.random(-360,360)
local bbb=math.random(-360,360)

  local F1 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.4,0,.4,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	Rotation=aaa
  })
  local F2 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.4,0,.4,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
     Parent = BillboardGui,
	Rotation=-aaa
  })
  local F3 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.2,0,.2,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	ZIndex=2,
	Rotation=bbb
   })
  local F4 = Create("Frame")({
	AnchorPoint=Vector2.new(.5,.5),
    Position = UDim2.new(.5, 0, .5, 0),
    Size = UDim2.new(.2,0,.2,0),
    BackgroundColor3 =MAINRUINCOLOR,
    BorderColor3 =MAINRUINCOLOR2,
	BorderSizePixel=4,
    Parent = BillboardGui,
	ZIndex=2,
 	Rotation=-bbb
   })

 --[[delay(0, function() -- no thank
    local Frames = Time / Rate
    for Frame = 1, Frames do
      wait(Rate)
      local Percent = Frame / Frames
      EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
      TextLabel.TextTransparency = Percent
    end
    if EffectPart and EffectPart.Parent then
      EffectPart:Destroy()
    end
  end)]]
local ha=EffectPart
local oring=ha.CFrame*CFrame.new(0,3.4,0)
F1:TweenPosition(UDim2.new(.2,0,.5,0), "Out", "Quint", 1,true)
F2:TweenPosition(UDim2.new(.8,0,.5,0), "Out", "Quint", 1,true)
F3:TweenPosition(UDim2.new(-.1,0,.5,0), "Out", "Quint", 1.5,true)
F4:TweenPosition(UDim2.new(1.1,0,.5,0), "Out", "Quint", 1.5,true)
for aaa=0,1.1,Time do
swait()
ha.CFrame=clerp(ha.CFrame,oring,.1)
F1.BackgroundTransparency=0+1*aaa
F2.BackgroundTransparency=0+1*aaa
F3.BackgroundTransparency=0+.5*aaa
F4.BackgroundTransparency=0+.5*aaa
F1.Rotation=F1.Rotation+math.random(5,10)
F2.Rotation=F2.Rotation-math.random(5,10)
F3.Rotation=F3.Rotation+math.random(3,6)
F4.Rotation=F4.Rotation-math.random(3,6)
end
for aaa=0,1,.1 do
swait()
TextLabel.TextTransparency=aaa
TextLabel.TextStrokeTransparency=aaa
F3.BackgroundTransparency=.5+.5*aaa
F4.BackgroundTransparency=.5+.5*aaa
F3.Rotation=F3.Rotation+math.random(3,6)
F4.Rotation=F4.Rotation-math.random(3,6)
end
--ha:Remove()
end))
end
function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChildOfClass("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam*attackmultiplier, maxdam*attackmultiplier, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
      local head = c:findFirstChild("UpperTorso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
          Damagefunc(head, head, mindam*attackmultiplier, maxdam*attackmultiplier, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end


function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end

function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

function SkullEffect(brickcolor,cframe,x1,y1,z1,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=4770583",vt(0,0,0),vt(x1,y1,z1))
--http://www.roblox.com/asset/?id=4770560
game:GetService("Debris"):AddItem(prt,2)
CF=prt.CFrame
coroutine.resume(coroutine.create(function(Part,Mesh,TehCF) 
for i=0,1,0.2 do
wait()
Part.CFrame=CF*cf(0,0,-0.4)
end
for i=0,1,delay do
wait()
--Part.CFrame=CF*cf((math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5,(math.random(-1,0)+math.random())/5)
Mesh.Scale=Mesh.Scale
end
for i=0,1,0.1 do
wait()
Part.Transparency=i
end
Part.Parent=nil
end),prt,msh,CF)
end
 
function MagicBlock(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
swait()
Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicSphere(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
prt.CFrame=prt.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicBlockSteady(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShock(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,effectz,1,1,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
local dec = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
local dec2 = decal(prt.Color,"http://www.roblox.com/asset/?id=874580939","Front",prt)
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
dec.Transparency=i
dec2.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAlt(brickcolor,cframe,x1,y1,x3,y3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,0.01))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockAltCircle(brickcolor,cframe,x1,z1,x3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0.1,0)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,-0.1,0)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,0,z3)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt(brickcolor,cframe,x1,y1,z1,x3,y3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,0)
end
Part.Parent=nil
end),prt,msh)
end

function MagicShockTrailAlt2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay,rottype)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.Material = "Neon"
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
	local rtype = rottype
for i=0,1,delay do
swait()
if rtype == 1 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,0.1)
elseif rtype == 2 then
prt.CFrame = prt.CFrame*CFrame.Angles(0,0,-0.1)
end
prt.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicBlock2(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,cframe)
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))*cframe
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicBlock3(brickcolor,cframe,Parent,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=false
prt.CFrame=cframe
msh=mesh("BlockMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
local wld=weld(prt,prt,Parent,euler(0,0,0)*cf(0,0,0))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,Weld) 
for i=0,1,delay do
wait()
Weld.C0=euler(i*20,0,0)
--Part.CFrame=Part.CFrame*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh,wld)
end
 
function MagicCircle2(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("CylinderMesh",prt,"","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
local prt2=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt2.Anchored=true
prt2.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh2=mesh("SpecialMesh",prt2,"Sphere","",vt(0,0,0),vt(0.5,0.5,0.5))
game:GetService("Debris"):AddItem(prt2,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,0.1 do
wait()
Part.CFrame=Part.CFrame*cf(0,0.5,0)
end
Part.Parent=nil
end),prt2,msh2)
end
for i=0,1,delay*2 do
wait()
Part.CFrame=Part.CFrame
Mesh.Scale=vt((x1+x3)-(x1+x3)*i,(y1+y3)-(y1+y3)*i,(z1+z3)-(z1+z3)*i)
end
Part.Parent=nil
end),prt,msh)
end
 
function MagicCircle(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function BreakEffect(brickcolor,cframe,x1,y1,z1)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*euler(math.random(-50,50),math.random(-50,50),math.random(-50,50))
local msh=mesh("SpecialMesh",prt,"Sphere","",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,CF,Numbb,randnumb) 
CF=Part.CFrame
Numbb=0
randnumb=math.random()/10
rand1=math.random()/10
for i=0,1,rand1 do
wait()
CF=CF*cf(0,math.random()/2,0)
--Part.CFrame=Part.CFrame*euler(0.5,0,0)*cf(0,1,0)
Part.CFrame=CF*euler(Numbb,0,0)
Part.Transparency=i
Numbb=Numbb+randnumb
end
Part.Parent=nil
end),prt,CF,Numbb,randnumb)
end
 
function MagicWaveThing(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=1051557",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*euler(0,0.7,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function WaveEffect(brickcolor,cframe,x1,y1,z1,x3,y3,z3,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe
msh=mesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=20329976",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,2)
coroutine.resume(coroutine.create(function(Part,Mesh) 
for i=0,1,delay do
wait()
Part.CFrame=Part.CFrame*cf(0,y3/2,0)
Part.Transparency=i
Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
end
Part.Parent=nil
end),prt,msh)
end
 
function StravEffect(brickcolor,cframe,x,y,z,x1,y1,z1,delay)
local prt=part(3,effectz,0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
prt.Anchored=true
prt.CFrame=cframe*cf(x,y,z)
msh=mesh("SpecialMesh",prt,"FileMesh","rbxassetid://168892363",vt(0,0,0),vt(x1,y1,z1))
game:GetService("Debris"):AddItem(prt,5)
coroutine.resume(coroutine.create(function(Part,Mesh,ex,why,zee) 
local num=math.random()
local num2=math.random(-3,2)+math.random()
local numm=0
for i=0,1,delay*2 do
swait()
Part.CFrame=cframe*euler(0,numm*num*10,0)*cf(ex,why,zee)*cf(-i*10,num2,0)
Part.Transparency=i
numm=numm+0.01
end
Part.Parent=nil
Mesh.Parent=nil
end),prt,msh,x,y,z)
end

function dmgstart(dmg,what)
	hitcon = what.Touched:connect(function(hit)
		local hum = hit.Parent:FindFirstChild("Humanoid")
		if hum and not hum:IsDescendantOf(Character) then
			hum:TakeDamage(dmg)
		end
	end)
end

function dmgstop()
	hitcon:disconnect()
end

function Cloak()
Face.Parent=nil
cloaked=true
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                spawn(function() 
                for i=0,1,0.2 do
                swait()
                v.Transparency=i
                end
                v.Transparency=1
                end)
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.2 do
                swait()
                derp.Transparency=i
                end
                derp.Transparency=1
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" then
                spawn(function() 
                for i=0,1,0.2 do
                swait()
                v.Transparency=i
                end
                v.Transparency=1
                end)
                end
        end
end
 
function UnCloak()
so("http://roblox.com/asset/?id=2767090",Torso,1,1.1) 
Face.Parent=Head 
cloaked=false
        for _,v in pairs(Torso.Parent:children()) do
                if v.className=="Part" and v.Name~="HumanoidRootPart" then
                spawn(function() 
                for i=0,1,0.1 do
                swait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end)
                end
                if v.className=="Hat" then
                hatp=v.Handle
                coroutine.resume(coroutine.create(function(derp) 
                for i=0,1,0.1 do
                swait()
                derp.Transparency=derp.Transparency-0.1
                end
                derp.Transparency=0
                end),hatp)
                end
        end
        for _,v in pairs(m:children()) do
                if v.className=="Part" and v.Name~="hitbox" and v.Name~='tip' then
                spawn(function() 
                for i=0,1,0.1 do
                swait()
                v.Transparency=v.Transparency-0.1
                end
                v.Transparency=0
                end)
                v.Transparency=0
                end
        end
end

local origcolor = BrickColor.new("Pastel light blue").Color
---- This section of explosions.

----


function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end)
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end

function wind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
		rng.Color = MAINRUINCOLOR
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end

function groundwind(type,pos,scale,value,speed)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=1051557"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.CFrame = rng.CFrame*CFrame.Angles(0,0.025*speed,0)
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2/5, scaler2)
end
rng:Destroy()
end)
end

function CameraManager()
  if TwoD and not CamInterrupt then
    if Humanoid.Health > 0 then
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Scriptable"
      Humanoid.AutoRotate = false
      if Booleans.GyroUse then
        Directer.MaxTorque = Vec3(0, huge, 0)
      else
        Directer.MaxTorque = Vec3(0, 0, 0)
      end
      if TargetInfo[1] ~= nil and TargetInfo[2] ~= nil then
        if Booleans.CamFollow then
          CPart.CFrame = cFrame(RootPart.Position, Vec3(TargetInfo[1].Position.X, RootPart.Position.Y, TargetInfo[1].Position.Z))
          Directer.CFrame = cFrame((RootPart.CFrame * cFrame(0, 0, 10)).p, TargetInfo[1].Position)
        else
          CPart.Position = RootPart.Position
        end
      else
        local ahead = (RootPart.CFrame * cFrame(0, 0, -3)).p
        CPart.CFrame = cFrame(RootPart.Position, Vec3(ahead.X, RootPart.Position.Y, ahead.Z))
      end
      Camera.CFrame = lerp(Camera.CFrame, CPart.CFrame * cFrame(25, 3, 0) * Euler(0, radian(90), 0), 0.2)
    else
      Camera.CameraSubject = Humanoid
      Camera.CameraType = "Custom"
    end
  end
end

function ring(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, 0)
end
rng:Destroy()
end)
end


function wave(type,pos,scale,value)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = origcolor
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=20329976"
rngm.Scale = scale
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value
end
rng.Transparency = rng.Transparency + 0.01
rngm.Scale = rngm.Scale + Vector3.new(scaler2, scaler2, scaler2)
end
rng:Destroy()
end)
end
local S = Instance.new("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end


function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end


function block2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function spherec(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if chaosmode == true then
rng.Color = Color3.fromRGB(math.random(0,255),math.random(0,255),math.random(0,255))
end
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function shard1(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Wedge"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
local type = type
local rotenable = rotatingop
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
if typeoftrans == "In" then
rng.Transparency = 1
end
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "FileMesh"
if typeofshape == "Normal" then
rngm.MeshId = "rbxassetid://662586858"
elseif typeofshape == "Round" then
rngm.MeshId = "rbxassetid://662585058"
end
rngm.Scale = scale
local scaler2 = 1/10
if type == "Add" then
scaler2 = 1*value/10
elseif type == "Divide" then
scaler2 = 1/value/10
end
local randomrot = math.random(1,2)
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed/10
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed/10
end
if rotenable == true then
if randomrot == 1 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(rotspeed*bonuspeed/2),0)
elseif randomrot == 2 then
rng.CFrame = rng.CFrame*CFrame.Angles(0,math.rad(-rotspeed*bonuspeed/2),0)
end
end
if typeoftrans == "Out" then
rng.Transparency = rng.Transparency + 0.01*bonuspeed
elseif typeoftrans == "In" then
rng.Transparency = rng.Transparency - 0.01*bonuspeed
end
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed/10, 0, scaler2*bonuspeed/10)
end
rng:Destroy()
end)
end

function PixelBlock(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function PixelBlockX(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function PixelBlockNeg(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 0
local speeder = FastSpeed/10
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder + 0.01*FastSpeed*bonuspeed/10
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
--rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale - Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end)
end

function block(bonuspeed,type,pos,scale,value,value2,value3,color,color3)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
        rng.Color = color
        rng.Color = color3
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.CFrame = rng.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end

local TweenService = game:GetService("TweenService")
function TweenFunction(part, X, Y, Z, T, LENGTH)
	local TweenP = part
	local TweenI = TweenInfo.new(LENGTH, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0)
	local TweenG = {
		Size = Vector3.new(X, Y, Z),
		Transparency = T
	}
	local Tween = TweenService:Create(TweenP, TweenI, TweenG)
	Tween:Play()
end
function TweenFunctionMESH(part, X, Y, Z, LENGTH)
	local TweenP = part
	local TweenI = TweenInfo.new(LENGTH, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0)
	local TweenG = {
		Scale = Vector3.new(X, Y, Z)
	}
	local Tween = TweenService:Create(TweenP, TweenI, TweenG)
	Tween:Play()
end
function ScreenBars(watval)
	spawn(function()
		Gui.BottomBar:TweenPosition(UDim2.new(0, 0, 1, 0), "Out", "Quint", 1, true)
		Gui.TopBar:TweenPosition(UDim2.new(0, 0, 0, -36), "Out", "Quint", 1, true)
		wait(watval)
		Gui.BottomBar:TweenPosition(UDim2.new(-0.009, 0, 1.136, 0), "Out", "Quint", 1, true)
		Gui.TopBar:TweenPosition(UDim2.new(0, 0, 0, -115), "Out", "Quint", 1, true)
	end)
end
	function focus(cframe,power,length)
	for i,v in pairs(game:GetService("Players"):GetChildren()) do
	local var = script.Effects.focus:Clone()
	var.Parent = v.PlayerGui
	local pw = var.Shakeval
	local lgth = var.MultLength
	local playervaluething = var.Player
	local Cframes = var.CFrame
	Cframes.Value = cframe
	pw.Value = power
	lgth.Value = length
	playervaluething.Value = plr.Name
	var.Disabled = false
	end
	end
function shardEffect(CFRAME, R, G, B)
	spawn(function()
		for i = 1, 10 do
			do
				local WP = Instance.new("WedgePart")
				WP.Anchored = true
				WP.CanCollide = false
				WP.Size = Vector3.new(0.05, 10, 10.6)
				WP.Material = "Neon"
				WP.Color = MAINRUINCOLOR
				WP.CFrame = CFRAME * CFrame.Angles(math.random(0, 360), math.random(0, 360), math.random(0, 360))
				WP.Parent = effectz
				TweenFunction(WP, 0.05, 1.22, 1.41, 1, 1)
				game.Debris:AddItem(WP, 1)
				local TP = Instance.new("Part")
				TP.Anchored = true
				TP.CanCollide = false
				TP.Size = Vector3.new(0.05, 1.22, 1.41)
				TP.Material = "Neon"
				TP.Transparency = 1
				TP.CFrame = CFRAME * CFrame.new(math.random(-100, 100), math.random(-100, 100), math.random(-100, 100)) * CFrame.Angles(math.random(0, 360), math.random(0, 360), math.random(0, 360))
				TP.Parent = effectz
				game.Debris:AddItem(TP, 5)
				spawn(function()
					for i = 0, 5, 0.25 do
						swait(2)
						WP.CFrame = WP.CFrame:lerp(TP.CFrame, 0.05)
					end
				end)
			end
		end
	end)
end

-- Credits to Gek for the Effect function!

function sphereRotMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
local ya = math.random(-5,5)
local xa = math.random(-5,5)
local za = math.random(-5,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
		rng.Color = color
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function sphereRot2MK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = 5
local xa = 5
local za = 5
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end
function sphereRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereRev2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereSRot2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
local ya = math.random(1,5)
local xa = math.random(1,5)
local za = math.random(1,5)
local y2a = 0
local x2a = 0
local z2a = 0
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
y2a=y2a+ya
z2a=z2a+za
x2a=x2a+xa
 rng.CFrame = pos
 rng.CFrame =  rng.CFrame*CFrame.Angles(math.rad(ya),math.rad(za),math.rad(xa))
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

function sphereMKColor(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", script.CurrentEffects)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = Vector3.new(x1,y1,z1)
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

function spinsquare(bonuspeed,FastSpeed,type,pos,sideleng,value,color,outerpos)
local type = type
local rng = Instance.new("Part", script.CurrentEffects)
        rng.Anchored = true
        rng.Color = color
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(sideleng,.1,sideleng)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local lookvec = rng.CFrame.lookVector
local scaler2 = 1
local speeder = FastSpeed
local spinval = math.random(1,10)
if math.random(1,2) == 1 then
	spinval = 0 - spinval
end
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + lookvec*speeder*bonuspeed
rng.Orientation = Vector3.new(0,sine*spinval,0)
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rng.Size = rng.Size - Vector3.new(scaler2*bonuspeed, 0, scaler2*bonuspeed)
end
rng:Destroy()
end))
end


function sphereMKt(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
TweenAnimate(rng,{C0=rng.CFrame*rng.CFrame.lookVector*speeder*bonuspeed},0.3,"Back","Out",0,false,0)
TweenAnimate(rng,{C0=rng.CFrame*rng.CFrame.lookVector*speeder*bonuspeed},0.3,"Back","Out",0,false,0)
rng:Destroy()
end)
end

function sphereMKr(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
						local SW = script.Mesh.VBLASTMESH2:Clone()
					SW.CFrame = rng.CFrame
					SW.Orientation = Vector3.new(0,0,0)
					SW.Parent = effectz
					TweenFunction(SW, 3, 2, 3, 1, 0.6)
					game:GetService("Debris"):AddItem(SW, 4)
rng:Destroy()
end)	
end
function trailMK(bonuspeed,FastSpeed,type,pos,x,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
local trl = Instance.new("Trail",rng)
	local a0 = Instance.new("Attachment",rng)
	a0.Position = Vector3.new(x/2,0,0)
	local a1 = Instance.new("Attachment",rng)
	a1.Position = Vector3.new(-x/2,0,0)
	trl.Attachment0 = a0
	trl.Attachment1 = a1
	trl.Color = ColorSequence.new(color)
	trl.Lifetime = 0.25
	trl.LightEmission = 1
	trl.WidthScale = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,0,0)})
	trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(0,0,0)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
trl.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,rng.Transparency,0),NumberSequenceKeypoint.new(1,1,0)})
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function sphereMKn(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos,lt)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
rng.Color = color
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end


function blockoutline(bonuspeed,type,pos,scale,value,value2,value3,color,outcol)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
local outline = Instance.new("SelectionBox",rng)
outline.Adornee = rng
outline.LineThickness = 0.05
outline.Color3 = outcol.Color
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rng.Size = rng.Size + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end)
end


function blockmk(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Brick"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", effectz)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.Color = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.CastShadow = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
spawn(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000)
else
break
end
end
end)
end
local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
spawn(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end)
end

local targetted
function dmg(dude)
if dude.Name ~= Character then
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
targetted = nil
CFuncs["Sound"].Create("rbxassetid://62339698", char, 0.5, 0.3)
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://241685484"
bld.Color = ColorSequence.new(MAINRUINCOLOR)
bld.Rate = 1000
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.1,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
v.Color = Color3.new(1,1,1)
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.02
end
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
bld.Speed = NumberRange.new(1,5)
bld.Acceleration = vt(0,10,0)
wait(0.5)
bld.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end
end

function dmgnr(dude)
local bgf = Instance.new("BodyGyro",dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
local val = Instance.new("BoolValue",dude)
val.Name = "IsHit"
local ds = coroutine.wrap(function()
dude:WaitForChild("Head"):BreakJoints()
wait(0.5)
targetted = nil
coroutine.resume(coroutine.create(function()
for i, v in pairs(dude:GetChildren()) do
if v:IsA("Accessory") then
v:Destroy()
end
if v:IsA("Humanoid") then
v:Destroy()
end
if v:IsA("CharacterMesh") then
v:Destroy()
end
if v:IsA("Model") then
v:Destroy()
end
if v:IsA("Part") or v:IsA("MeshPart") then
for x, o in pairs(v:GetChildren()) do
if o:IsA("Decal") then
o:Destroy()
end
end
coroutine.resume(coroutine.create(function()
v.Material = "Neon"
v.CanCollide = false
local bld = Instance.new("ParticleEmitter",v)
bld.LightEmission = 1
bld.Texture = "rbxassetid://241685484"
bld.Color = ColorSequence.new(MAINRUINCOLOR)
bld.Rate = 50
bld.Lifetime = NumberRange.new(1)
bld.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.75,0),NumberSequenceKeypoint.new(1,0,0)})
bld.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)})
bld.Speed = NumberRange.new(0,0)
bld.VelocitySpread = 50000
bld.Rotation = NumberRange.new(-500,500)
bld.RotSpeed = NumberRange.new(-500,500)
        local sbs = Instance.new("BodyPosition", v)
        sbs.P = 3000
        sbs.D = 1000
        sbs.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
        sbs.position = v.Position + Vector3.new(math.random(-5,5),math.random(-5,5),math.random(-5,5))
v.Color = MAINRUINCOLOR
coroutine.resume(coroutine.create(function()
for i = 0, 49 do
swait(1)
v.Transparency = v.Transparency + 0.02
end
CFuncs["Sound"].Create("rbxassetid://1192402877", v, 0.25, 1)
bld.Speed = NumberRange.new(1,5)
bld.Acceleration = vt(0,10,0)
wait(0.5)
bld.Enabled = false
wait(3)
v:Destroy()
dude:Destroy()
end))
end))
end
end
end))
end)
ds()
end


function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

-- Functions are ready.
local storehumanoidWS = 70
function symbolizeBlink(guipar,size,img,color,bonussize,vol,pit,soundid,spar,rotationenabled,rotsp,delay)
local bgui,imgc = createBGCircle(size,guipar,color)
bgui.AlwaysOnTop = true
imgc.Image = "rbxassetid://" ..img
local rrot = math.random(1,2)
CFuncs["Sound"].Create("rbxassetid://" ..soundid, spar, vol,pit)
coroutine.resume(coroutine.create(function()
for i = 0, 24*delay do
swait()
if rotationenabled == true then
if rrot == 1 then
imgc.Rotation = imgc.Rotation + rotsp
elseif rrot == 2 then
imgc.Rotation = imgc.Rotation - rotsp
end
end
bgui.Size = bgui.Size + UDim2.new(1*bonussize/delay,0,1*bonussize/delay,0)
imgc.ImageTransparency = imgc.ImageTransparency + 0.04/delay
end
bgui:Destroy()
end))
end
function brst()
for i = 0, 1 do
CFuncs["Sound"].Create("rbxassetid://1042716828", root, 5, 1)
CFuncs["Sound"].Create("rbxassetid://1042693018", root, 5, 0.8)
CFuncs["Sound"].Create("rbxassetid://1192402877", root, 4,0.75)
CFuncs["Sound"].Create("rbxassetid://1664711478", root, 4,1)
CFuncs["Sound"].Create("rbxassetid://763718160", root, 4, 0.75)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 8, 0.9)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 6, 0.8)
CFuncs["Sound"].Create("rbxassetid://782353443", root, 4, 0.7)
end
symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,1)
symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,2)
symbolizeBlink(Torso,0,2109052855,MAINRUINCOLOR,30,0,0,0,root,false,0,4)
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",Torso)
eff.Texture = "rbxassetid://2273224484"
eff.LightEmission = 1
eff.Color = ColorSequence.new(MAINRUINCOLOR)
eff.Rate = 15000
eff.Lifetime = NumberRange.new(0.5,1)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,60,0),NumberSequenceKeypoint.new(0.2,3,0),NumberSequenceKeypoint.new(0.8,24,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2,0,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(100,650)
eff.Drag = 5
eff.Rotation = NumberRange.new(-500,500)
eff.VelocitySpread = 9000
eff.RotSpeed = NumberRange.new(-50,50)
wait(0.35)
eff.Enabled = false
end))
spherec(1,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),1,1,1,MAINRUINCOLOR2)
spherec(2,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),1.5,1.5,1.5,MAINRUINCOLOR)
spherec(3,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),2,2,2,MAINRUINCOLOR2)
spherec(4,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),2.5,2.5,2.5,MAINRUINCOLOR)
for i = 0,20 do
sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
end
end

function RecolorThing(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
		for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
end
if v:IsA("ImageLabel") then
	v.ImageColor3 = MAINRUINCOLOR
	end
if v.Name == "Ring" or v.Name == "Ring2" then
v.ImageColor3 = MAINRUINCOLOR2
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR2
v.BackgroundColor3 = MAINRUINCOLOR
end
end
for i, v in pairs(mw2:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") or v:IsA("Part") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
if v.Name == "Force Field" then
v.Material = "ForceField"
v.Mesh.VertexColor = Vector3.new(two.r,two.g,two.b)
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
brst()
ringgu.Ring1.Color = one
ringgu.Ring2.Color = two
ringgu.Ring3.Color = one
ringgu.Ring4.Color = two
for i, v in pairs(mw1:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
for i,v in pairs(gauntneon)do
v.Color = one
v.Material = "Neon"
end
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=100; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=130; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
end

function RecolorThingQuiet(one,two,three,four,five,exonetran,exone,extwotran,extwo,secondaryenabled,sectrailenabled)
for i, v in pairs(mw2:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
if v.Name == "Force Field" then
v.Material = "ForceField"
v.Mesh.VertexColor = Vector3.new(two.r,two.g,two.b)
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
		for i,v in pairs(Gui:GetDescendants())do
if v:IsA("Frame") then
v.BackgroundColor3 = MAINRUINCOLOR
end
if v:IsA("ImageLabel") then
	v.ImageColor3 = MAINRUINCOLOR
	end
if v.Name == "Ring" or v.Name == "Ring2" then
v.ImageColor3 = MAINRUINCOLOR2
end
if v:IsA("TextLabel") then
v.TextColor3 = MAINRUINCOLOR2
v.BackgroundColor3 = MAINRUINCOLOR
end
end
ringgu.Ring1.Color = one
ringgu.Ring2.Color = two
ringgu.Ring3.Color = one
ringgu.Ring4.Color = two
for i, v in pairs(mw1:GetDescendants()) do
if v:IsA("BasePart") or v:IsA("UnionOperation") then
v.Color = one
v.Material = "Neon"
if v.Name == "Color2" then
v.Color = two
end
elseif v:IsA("Trail") or v:IsA("ParticleEmitter") or v:IsA("Beam") then
if v.Name == "Trail1" then
v.Color = ColorSequence.new(one)
elseif v.Name == "Trail2" then
	v.Color = ColorSequence.new(two)
else
v.Color = ColorSequence.new(one)
end
end
end
for i,v in pairs(gauntneon)do
v.Color = one
v.Material = "Neon"
end
end
RecolorThingQuiet(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)

function RecolorTextAndRename(name,col1,col2,font)
modet.TextStrokeColor3 = col2
modet.TextColor3 = col1
modet.Font = font
modet.Text = name
Gui.Stats.Mode.Text = name
bilguit.FX1.ImageColor3 = MAINRUINCOLOR2
bilguit.FX2.ImageColor3 = MAINRUINCOLOR
bilguit.FX3.ImageColor3 = MAINRUINCOLOR2
end

function createBGCircle(size,parent,color)
local bgui = Instance.new("BillboardGui",parent)
bgui.Size = UDim2.new(size, 0, size, 0)
local imgc = Instance.new("ImageLabel",bgui)
imgc.BackgroundTransparency = 1
imgc.ImageTransparency = 0
imgc.Size = UDim2.new(1,0,1,0)
imgc.Image = "rbxassetid://997291547" --997291547,521073910
imgc.ImageColor3 = color
return bgui,imgc
end

local bguis = Instance.new("BillboardGui",tors)
bguis.Size = UDim2.new(15, 0, 15, 0)
local imgca = Instance.new("ImageLabel",bguis)
imgca.BackgroundTransparency = 1
imgca.ImageTransparency = 1
imgca.Size = UDim2.new(1,0,1,0)
imgca.Image = "rbxassetid://2312119891" --997291547,521073910,2312119891
imgca.ImageColor3 = BrickColor.new("Pink").Color

local warngui = script.bwarn
warngui.Parent = hed
warngui.Enabled = true
local markimg = warngui.warnimage
markimg.ImageTransparency = 1
function WARNINGMARK(frequen,sound)
spawn(function()
if sound==true then
CFuncs["Sound"].Create("rbxassetid://2923164079", char, 1, 1.1)
else
end
if frequen then
for i = 0, frequen do
repeat
markimg.ImageTransparency = markimg.ImageTransparency - 0.05
swait()
until markimg.ImageTransparency < 0.5
repeat
markimg.ImageTransparency = markimg.ImageTransparency + 0.05
swait()
until markimg.ImageTransparency == 1
end
else
for i = 0, 1 do
repeat
markimg.ImageTransparency = markimg.ImageTransparency - 0.05
swait()
until markimg.ImageTransparency < 0.5
repeat
markimg.ImageTransparency = markimg.ImageTransparency + 0.05
swait()
until markimg.ImageTransparency == 1
end
end
end)
end
-- WARNINGMARK(3,true)


----------------------------------- Abilities
local charge = false
function opening()
attack = true
hum.WalkSpeed = 0
	WARNINGMARK(3,true)
    for i = 0,4,0.1 do
        swait()
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(0)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(0)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.01 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-30),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.05,0.65 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(180 - 3 * math.cos(sine / 32)),math.rad(0 + 8 * math.cos(sine / 23)),math.rad(-42 + 3 * math.cos(sine / 15))),.1)
LW.C0=clerp(LW.C0,cf(-1.05,0.65 + 0.075 * math.cos(sine / 18),-0.5)*angles(math.rad(170 - 3 * math.cos(sine / 32)),math.rad(0 - 8 * math.cos(sine / 23)),math.rad(42 - 3 * math.cos(sine / 15))),.1)
    end
CamShakeAll2({
    Duration=2; -- Lasts for .1 seconds
    Intensity=10; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=10000; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=10000; -- Camera dist from origin when the shake goes away
    Origin=tors.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
    for i = 0,20,0.1 do
        swait()
		slash(math.random(30,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,2500)/250,BrickColor.new("Really red").Color)
		slash(math.random(30,50)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(500,2500)/250,BrickColor.new("Really black").Color)
		sphere2(8,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,250,1,MAINRUINCOLOR)
		sphere2(8,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),1,250,1,MAINRUINCOLOR2)
		sphere2(6,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),5,5,5,MAINRUINCOLOR)
		sphere2(7,"Add",root.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),5.1,5.1,5.1,MAINRUINCOLOR2)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-5.5),math.rad(-30)),.5)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 20),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(5.5),math.rad(30)),.5)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.3 + 0.03 * math.cos(sine / 20),0 + 0.1 * math.cos(sine / 20))*angles(math.rad(-30),math.rad(0),math.rad(0)),.5)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-32 + math.random(-30,30)),math.rad(0 + math.random(-30,30)),math.rad(0 + math.random(-30,30))),.5)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(-40 - 3 * math.cos(sine / 32) + math.random(-30,30)),math.rad(0 + 8 * math.cos(sine / 23) + math.random(-30,30)),math.rad(50 + 3 * math.cos(sine / 15) + math.random(-30,30))),.5)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.075 * math.cos(sine / 18),0)*angles(math.rad(-40 - 3 * math.cos(sine / 32) + math.random(-30,30)),math.rad(0 - 8 * math.cos(sine / 23) + math.random(-30,30)),math.rad(-50 - 3 * math.cos(sine / 15) + math.random(-30,30))),.5)
    end
hum.WalkSpeed = storehumanoidWS
attack = false
end
spawn(function()
opening()
end)

function Heal()
	attack = true
	hum.WalkSpeed = 0
	ScreenBars(2.5)
	    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,0)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.3)
	    end
	CFuncs["Sound"].Create("rbxassetid://356427062", root, 4,1.2)
for i,v in pairs(HealEff:GetChildren())do
v:Emit(20)
end
hum.Health = hum.Health + hum.MaxHealth/3
    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,0)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
    end
hum.WalkSpeed = storehumanoidWS
attack = false
cooldown = 6
end


function levelup()
for i,v in pairs(stupidgui:GetDescendants())do
v.BackgroundColor3 = MAINRUINCOLOR
v.TextStrokeColor3 = MAINRUINCOLOR2
v.TextColor3 = MAINRUINCOLOR
end
CFuncs["Sound"].Create("rbxassetid://2513971488", root, 10, 1)
stupidgui.stupidthing.stupidthingv2.Text = "Level: ".. level
if BarrierEnabled == true then
stupidgui.stupidthing.stupidthingv3.Text = "BARRIER: ".. hum.Health.. "/".. hum.MaxHealth
elseif BarrierEnabled == false then
stupidgui.stupidthing.stupidthingv3.Text = "HP: ".. hum.Health.. "/".. hum.MaxHealth
end
stupidgui.stupidthing:TweenPosition(UDim2.new(0,0,0.373,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.4,true) --
if switchb == true then
	MLT.Eth:TweenPosition(UDim2.new(.3,0,.2,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,.4,true)
end
wait(4)
stupidgui.stupidthing:TweenPosition(UDim2.new(-0.298,0,0.373,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.4,true) -- {-0.298, 0},{0.373, 0}
if switchb == true then
	MLT.Eth:TweenPosition(UDim2.new(.011,0,.2,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,.4,true)
end
end

function attackone()
attack = true
hum.WalkSpeed = 0
for i = 0,1,0.1 do
swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(15.6),math.rad(-21.9),math.rad(6))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(-19.5),math.rad(15.6),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.6,0)*angles(math.rad(-18),math.rad(3.4),math.rad(-10.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.3,-0.1)*angles(math.rad(-160.9),math.rad(0),math.rad(28.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,Alpha)
end
CFuncs["Sound"].Create("rbxassetid://200632136", root, 1, 1.1)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
for i = 0,1,0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-19.7),math.rad(11.9),math.rad(-8.9))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.2,-0.2)*angles(math.rad(-62.6),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.9,-0.3)*angles(math.rad(20.8),math.rad(-9.2),math.rad(13))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0.4)*angles(math.rad(-76.7),math.rad(10.5),math.rad(-2.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.2,-0.7)*angles(math.rad(71.2),math.rad(-2.1),math.rad(-3.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,Alpha)
end
attack = false
charge = false
hum.WalkSpeed = storehumanoidWS
end

function noob()
for i = 0,20,0.2 do
swait()
Head.Mesh.Scale = Head.Mesh.Scale + Vector3.new(.1, .1, .1)
end
end

function attacktwo()
attack = true
local rootCF=euler(-1.57,0,3.14)
local keptcolor = MAINRUINCOLOR
local al=.2
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(100))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(15),math.rad(0),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.2,0.5,-0.25)*angles(math.rad(-10),math.rad(-10),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-1.35,0.35,-0.4)*angles(math.rad(90),math.rad(2),math.rad(80))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(.75,-1,0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(-100),math.rad(5))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-6),math.rad(10),math.rad(0))},al,typ,direc,0,false,0)
wait(.2)
CFuncs["Sound"].Create("rbxassetid://200632136", root, 1, 0.7)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
spawn(function()
for i = 0,20 do
wait(0.01)
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
end
end)
local al=.25
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(5),math.rad(2),math.rad(100))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(0),math.rad(0),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.8,0.5,-0.25)*angles(math.rad(-10),math.rad(-10),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-.7,0.35,-0.4)*angles(math.rad(90),math.rad(2),math.rad(80))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(1.2,-.5,0.5)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(20),math.rad(-100),math.rad(10))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(10),math.rad(-10))},al,typ,direc,0,false,0)
root.Anchored=true
TweenAnimate(root,{CFrame=root.CFrame*CFrame.new(0,0,-12.5)},.3,"Sine","Out",0,false,0)
--root.CFrame=root.CFrame*CFrame.new(0,0,.075)
wait(0.3)
root.Anchored=false
attack = false
end

function attackthree()
attack = true
hum.WalkSpeed = 0
local rootCF=euler(-1.57,0,3.14)
local keptcolor = MAINRUINCOLOR
local al=.3
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(40),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.5,0.5,0)*angles(math.rad(-60),math.rad(0),math.rad(10))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-1.5,0.5,0)*angles(math.rad(-60),math.rad(0),math.rad(-10))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(60),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-50),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
wait(0.3)
CFuncs["Sound"].Create("rbxassetid://182765513", root, 4, 1)
local hitb = Instance.new("Part", char)
        hitb.Anchored = true
        hitb.CanCollide = false
        hitb.FormFactor = 3
        hitb.Name = "Ring"
        hitb.Material = "Neon"
        hitb.Size = Vector3.new(1, 1, 1)
        hitb.Transparency = 1
        hitb.TopSurface = 0
        hitb.BottomSurface = 0
hitb.CFrame = root.CFrame + root.CFrame.lookVector*2
MagniDamage(hitb, 3, 30,60, 0, "Normal")
hitb:Destroy()
local al=.4
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(-50),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.5,0.5,0)*angles(math.rad(-60),math.rad(0),math.rad(10))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-1.5,0.5,0)*angles(math.rad(-60),math.rad(0),math.rad(-10))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-60),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(50),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
wait(0.4)
hum.WalkSpeed = storehumanoidWS
attack = false
end

function Reanimated()
local targetted = nil
if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
targetted = mouse.Target.Parent
end
if targetted ~= nil then
	attack = true
	hum.WalkSpeed = 0
	local rootCF=euler(-1.57,0,3.14)
local al=.4
local typ="Back"
local direc="Out"
TweenAnimate(RootJoint,{C0=rootCF*cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(90))},al,typ,direc,0,false,0)
TweenAnimate(Torso.Neck,{C0=necko*angles(math.rad(0),math.rad(0),math.rad(-90))},al,typ,direc,0,false,0)
TweenAnimate(RW,{C0=cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(90))},al,typ,direc,0,false,0)
TweenAnimate(LW,{C0=cf(-1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(-10))},al,typ,direc,0,false,0)
TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(0),math.rad(0),math.rad(0))},al,typ,direc,0,false,0)
wait(0.4)
CFuncs["Sound"].Create("rbxassetid://1222405264", targetted.Torso, 10, 1)
spherec(4,"Add",targetted.Torso.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),0.5,1,0.5,MAINRUINCOLOR)
wind("Add",targetted.Torso.CFrame*CFrame.Angles(math.rad(0),0,0),Vector3.new(0.1,0.3,0.1),math.random(2,3),math.random(2,10))
for i = 0,20 do
sphere2(5,"Add",targetted.Torso.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
end
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=100; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=130; -- Camera dist from origin when the shake goes away
    Origin=targetted.Torso.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
dmg(targetted)
attack = false
hum.WalkSpeed = storehumanoidWS
end
end

function fireboll()
attack = true
hum.WalkSpeed = 0
CFuncs["Sound"].Create("rbxassetid://1544022435", tors, 10, 1)
  	local Alpha = .3
  	twanim = TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(24.4),math.rad(-24.3),math.rad(10.6))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(-29.1),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-21.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.4,0.8,0)*angles(math.rad(-37.5),math.rad(18.4),math.rad(-25.5))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,0.7)*angles(math.rad(70.6),math.rad(0),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 = cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
	twanim.Completed:Wait()
local orb = Instance.new("Part", char)
        orb.Color = MAINRUINCOLOR
        orb.CanCollide = false
        orb.FormFactor = 3
        orb.Name = "Ring"
        orb.Material = "Neon"
        orb.Size = Vector3.new(1, 1, 1)
        orb.Transparency = 0
        orb.TopSurface = 0
        orb.BottomSurface = 0
        local orbm = Instance.new("SpecialMesh", orb)
        orbm.MeshType = "Sphere"
orbm.Name = "SizeMesh"
orbm.Scale = vt(2,2,2)
orb.CFrame = root.CFrame + root.CFrame.lookVector*3
local effc = script.FireballFlame:Clone()
effc.Parent = orb
	local a = Instance.new("Part",workspace)
	a.Name = "Direction"	
	a.Anchored = true
	a.BrickColor = bc("Bright red")
	local ht = Instance.new("Part",workspace)
	ht.Name = "hitPoint"
	ht.Anchored = true
	ht.BrickColor = bc("Bright red")
	ht.Transparency = 1
	ht.Position = mouse.Hit.p
a.Material = "Neon"
a.Transparency = 1
	a.CanCollide = false
	local ray = Ray.new(
	    orb.CFrame.p,                           -- origin
	    (mouse.Hit.p - orb.CFrame.p).unit * 500 -- direction
	) 
	local ignore = orb
	local hit, position, normal = workspace:FindPartOnRay(ray, ignore)
	a.BottomSurface = 10
	a.TopSurface = 10
	local distance = (orb.CFrame.p - position).magnitude
	a.Size = Vector3.new(0.1, 0.1, 0.1)
	a.CFrame = CFrame.new(orb.CFrame.p, position) * CFrame.new(0, 0, 0)
orb.CFrame = a.CFrame
a:Destroy()
local bv = Instance.new("BodyVelocity")
bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
bv.velocity = orb.CFrame.lookVector*150
bv.Parent = orb
game:GetService("Debris"):AddItem(orb, 10)
local hitted = false
coroutine.resume(coroutine.create(function()
while true do
swait()
local hit =orb.Touched:connect(function(hit) 
	if hitted == false and hit.Parent ~= char then
	hitted = true
	effc.Enabled = false
	    CFuncs["Sound"].Create("rbxassetid://2042692050", effc.Parent, 10, 1)
	ht:Destroy()
	spherec(4,"Add",orb.CFrame*CFrame.Angles(0,0,0),vt(0,0,0),0.5,0.5,0.5,MAINRUINCOLOR)
	for i = 0,6 do
	wind("Add",orb.CFrame*CFrame.Angles(math.rad(0),0,0),Vector3.new(0.1,0.3,0.1),math.random(2,3),math.random(2,10))
	end
	for i = 0,20 do
	sphere2(5,"Add",orb.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
	end
CamShakeAll2({
    Duration=0.6; -- Lasts for .1 seconds
    Intensity=3; -- Intensity of 5
    Position=Vector3.new(2,2,2); -- What axises the shake effects and how much (position)
    Rotation=Vector3.new(2,2,6); -- What axises the shake effects and how much (rotation)
    DropDist=100; -- Camera dist from origin when the shake starts to gradually get weaker
    IneffectiveDist=130; -- Camera dist from origin when the shake goes away
    Origin=orb.Position; -- Where the shake is coming from (Part, CFrame, or Vector3)
})
	MagniDamage(orb, 25, 20,30, 0, "Normal")
orb.Anchored = true
orb.Transparency = 1
orb:Destroy()
end
end)
end
end))
  	local Alpha = .3
  	twanim = TweenAnimate(RootJoint,{C0=cf(0,0,0)*angles(math.rad(-11.8),math.rad(25.7),math.rad(-8.4))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-1,0)*angles(math.rad(8.9),math.rad(0),math.rad(8.8))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(-39.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.4,0.8,0)*angles(math.rad(-37.5),math.rad(18.4),math.rad(-25.5))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1,0.4,-0.8)*angles(math.rad(70.6),math.rad(0),math.rad(-37.2))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 = cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
	twanim.Completed:Wait()
hum.WalkSpeed = storehumanoidWS
attack = false
end

function ashes()
	hum.WalkSpeed = 0
attack = true
CFuncs["Sound"].Create("rbxassetid://585802464", char, 1, 1)
  	local Alpha = 3.735
  	twanim = TweenAnimate(RootJoint,{C0=cf(0,-0.4,-0.6)*angles(math.rad(-36.5),math.rad(0),math.rad(0))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-0.4,-0.5)*angles(math.rad(36.5),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1.1,-0.4)*angles(math.rad(-18),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.4,0.7,0)*angles(math.rad(-94.3),math.rad(-82.9),math.rad(-62.3))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.8,0)*angles(math.rad(-37.9),math.rad(-2),math.rad(13.2))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(1.5),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
	for i = 0,140 do
	swait()	
	sphereMK(2.5,-1.5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),3.5,3.5,45,-0.035,MAINRUINCOLOR,100)
	end
	local vel = Instance.new("BodyPosition", root)
vel.P = 10000
vel.D = 1000
vel.maxForce = Vector3.new(50000000000, 10e10, 50000000000)
vel.position = root.CFrame.p + vt(0,250,0)
for i = 0, 49 do
slash(math.random(10,100)/10,3,true,"Round","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-10,10)),math.rad(math.random(-360,360)),math.rad(math.random(-10,10))),vt(0.05,0.01,0.05),math.random(25,500)/250,BrickColor.new("White").Color)
end
  	local Alpha = 0.3
  	comp = TweenAnimate(RootJoint,{C0=cf(0,0.4,-0.6)*angles(math.rad(32.7),math.rad(0),math.rad(0))*RootCF},0.1,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-0.4,-0.7)*angles(math.rad(3.3),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1.1,-0.4)*angles(math.rad(-18),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.4,0.7,0)*angles(math.rad(-94.3),math.rad(-82.9),math.rad(-62.3))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.4,0.8,0)*angles(math.rad(-37.9),math.rad(-2),math.rad(13.2))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(1.5),math.rad(0),math.rad(0))*necko},Alpha,'Linear','Out',0,false,0)
	comp.Completed:Wait()
	wait(1.1)
	newbosschatfunc("Looks like you'll burn to ashes...",modet.TextStrokeColor3,modet.TextStrokeColor3,250)
	CFuncs["Sound"].Create("rbxassetid://163619849", char, 1, 1)
  	local Alpha = 0.5
  	comp = TweenAnimate(RootJoint,{C0=cf(0,0.2,-0.5)*angles(math.rad(-28.9),math.rad(0),math.rad(0))*RootCF},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-0.8,-0.9)*angles(math.rad(-26),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1.2,-0.3)*angles(math.rad(-42.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.5,0.1)*angles(math.rad(-120.7),math.rad(-20.5),math.rad(-86.5))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.3,0.6,0.2)*angles(math.rad(-72.6),math.rad(7.8),math.rad(64.6))},Alpha,'Back','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,-0.2)*angles(math.rad(9.7),math.rad(0),math.rad(0))*necko},Alpha,'Back','Out',0,false,0)
	comp.Completed:Wait()
	wait(1)
	vel:Destroy()
	RootPart.CFrame = mouse.Hit *CFrame.new(0,2,0)
	newbosschatfunc("Hya!",modet.TextStrokeColor3,modet.TextStrokeColor3,250)
	CFuncs["Sound"].Create("rbxassetid://255679373", char, 5.25,1)
	MagniDamage(root, 80, 79,90, 0, "Burn")
for i = 1, 36 do
slash(math.random(10,30)/10,5,true,"Round","Add","Out",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(0.01,0.01,0.01),math.random(150,350)/250,MAINRUINCOLOR)
end
sphere(2.5,"Add",root.CFrame,vt(0,0,0),3,MAINRUINCOLOR)
for i = 0,3,0.1 do
sphereMK(2.5,-1,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),2.5,2.5,25,-0.025,MAINRUINCOLOR,0)
end
hum.WalkSpeed = storehumanoidWS
attack = false
end


 
-------------------------------------

if Character:findFirstChild("Animate") then
Character:findFirstChild("Animate"):Remove()
end


if Humanoid:findFirstChild("Animator") then
Humanoid:findFirstChild("Animator"):Remove()
end



-------------------------------------
--[[
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(0),math.rad(0)),.1)
]]--

-------------------------------------

local attacktype = 1
mouse.Button1Down:connect(function()
  if attack == false and attacktype == 1 then
    attacktype = 2
    attackone()
  elseif attack == false and attacktype == 2 then
    attacktype = 3
    attacktwo()
  elseif attack == false and attacktype == 3 then
    attacktype = 1
    attackthree()
  elseif attack == false and attacktype == 4 then
    attacktype = 1
    --attackfour()
  end
end)
mouse.KeyDown:connect(function(k)
	if switch == 1 then
if k == "1" and attack == false and Mode ~= 1 then
storehumanoidWS = 70
Mode = 1
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Really red").Color
MAINRUINCOLOR2 = BrickColor.new("Maroon").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
newTheme("rbxassetid://1327600769",0,1,1.25)
RecolorTextAndRename("Stigmatist",MAINRUINCOLOR,MAINRUINCOLOR2,"Gotham")
end
if k == "2" and attack == false and Mode ~= 2 then
storehumanoidWS = 16
Mode = 2
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Royal purple").Color
MAINRUINCOLOR2 = BrickColor.new("Dark blue").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
newTheme("rbxassetid://2835035033",0,1,1.25)
RecolorTextAndRename("Manipulate",MAINRUINCOLOR,MAINRUINCOLOR2,"Code")
end
if k == "3" and attack == false and Mode ~= 3 then
storehumanoidWS = 70
Mode = 3
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Really black").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
newTheme("rbxassetid://3494472936",0,1,1.25)
RecolorTextAndRename("Fraternity",MAINRUINCOLOR,MAINRUINCOLOR2,"Fantasy")
end
if k == "4" and attack == false and Mode ~= 4 then
storehumanoidWS = 70
Mode = 4
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Neon orange").Color
MAINRUINCOLOR2 = BrickColor.new("CGA brown").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
if plr.Name == "GodzPlaysRB" then
newTheme("rbxassetid://1881304457",0,1,1.25)
else
newTheme("rbxassetid://260928315",0,1,1.25)
end
RecolorTextAndRename("Ignition",MAINRUINCOLOR,Color3.fromRGB(215,100,0),"Gotham")
end
if k == "5" and attack == false and Mode ~= 5 then
storehumanoidWS = 70
Mode = 5
hum.WalkSpeed = storehumanoidWS
--ScreenBars(2.2)
MAINRUINCOLOR = BrickColor.new("Dark blue").Color
MAINRUINCOLOR2 = BrickColor.new("Royal purple").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Galactica",MAINRUINCOLOR,Color3.fromRGB(0,0,MAINRUINCOLOR.b-50),"Arcade")
newTheme("rbxassetid://3568106688",0,1,1.25)
end
if k == "6" and attack == false and Mode ~= 6 then
storehumanoidWS = 16
Mode = 6
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Neon orange").Color
MAINRUINCOLOR2 = BrickColor.new("CGA brown").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
if nipsexist == true then
RecolorTextAndRename("U-K-E",BrickColor.new("White").Color,MAINRUINCOLOR2,"Cartoon")
else
RecolorTextAndRename("L-O-V-E",BrickColor.new("White").Color,MAINRUINCOLOR2,"Arcade")
end
newTheme("rbxassetid://1426044282",0,1,1.25)
end
if k == "7" and attack == false and Mode ~= 7 then
storehumanoidWS = 16
Mode = 7
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Black").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("DESOLATE",BrickColor.new("Black").Color,MAINRUINCOLOR2,"Arcade")
newTheme("rbxassetid://705302406",0,1,1.25)
end
if k == "8" and attack == false and Mode ~= 8 then
storehumanoidWS = 16
Mode = 8
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Maroon").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Predator...",BrickColor.new("Really black").Color,MAINRUINCOLOR,"Gotham")
newTheme("rbxassetid://3103675988",0,1,1.25)
end
if k == "9" and attack == false and Mode ~= 9 then
storehumanoidWS = 16
Mode = 9
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Bright yellow").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Disinterestedness",BrickColor.new("White").Color,MAINRUINCOLOR,"Fantasy")
newTheme("rbxassetid://2127419486",0,1,1.25)
end
if k == "0" and attack == false and Mode ~= 10 then
storehumanoidWS = 70
Mode = 10
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Steel blue").Color
MAINRUINCOLOR2 = BrickColor.new("Storm blue").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("隠された",BrickColor.new("White").Color,MAINRUINCOLOR,"Code")
newTheme("rbxassetid://3329947102",0,1,1.25)
elseif switch == 2 then
end
if k == "m" and attack == false and Mode == 6 then
storehumanoidWS = 16
hum.WalkSpeed = 0
Mode = 61
attack = true
	    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,-0.15,0)* angles(math.rad(10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(-90)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.25, 0.5, -0.5) * angles(math.rad(40), math.rad(0), math.rad(70)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(-10)),.3)
	    end
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Maroon").Color
MAINRUINCOLOR2 = BrickColor.new("Really red").Color
RecolorTextAndRename("HOSTILITY",BrickColor.new("White").Color,MAINRUINCOLOR2,"Gotham")
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
newTheme("rbxassetid://165704299",0,1,1.25)
    for i = 0,2,0.1 do
        swait()
            RootJoint.C0 = clerp(RootJoint.C0,RootCF*cf(0,0.15,0)* angles(math.rad(-10),math.rad(0),math.rad(0)),0.3)
Torso.Neck.C0 = clerp(Torso.Neck.C0,necko *angles(math.rad(-10),math.rad(0),math.rad(0)),.3)
RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(120)), 0.3)
LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-120)), 0.3)
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-1.5),math.rad(0),math.rad(-10)),.3)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(10)),.3)
    end
attack = false
end
	elseif switch == 2 then
	if k == "1" and attack == false and Mode ~= 11 then
storehumanoidWS = 70
Mode = 11
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Dark green").Color
MAINRUINCOLOR2 = BrickColor.new("Slime green").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("VOYAGER",BrickColor.new("White").Color,MAINRUINCOLOR,"Gotham")
newTheme("rbxassetid://461877994",0,1,1.25)
	end
		if k == "2" and attack == false and Mode ~= 12 then
storehumanoidWS = 70
Mode = 12
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Pink").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Tranquillity",BrickColor.new("White").Color,MAINRUINCOLOR,"Cartoon")
newTheme("rbxassetid://2142544796",0,1,1.25)
		end
if k == "3" and attack == false and Mode ~= 13 then
storehumanoidWS = 70
Mode = 13
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Royal purple").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Deception",BrickColor.new("Really black").Color,MAINRUINCOLOR,"Gotham")
newTheme("rbxassetid://4508176762",0,1,1.25)
end
if k == "m" and attack == false and Mode == 13 then
storehumanoidWS = 70
Mode = 131
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Really black").Color
MAINRUINCOLOR2 = BrickColor.new("Really black").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Darkness",BrickColor.new("White").Color,MAINRUINCOLOR,"Fantasy")
newTheme("rbxassetid://1354768917",0,1,1.25)
end
if k == "4" and attack == false and Mode ~= 14 then
storehumanoidWS = 16
Mode = 14
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new(.075,.25,.65).Color -- 1,.65,.3
MAINRUINCOLOR2 = BrickColor.new(.3,.65,1).Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("TRANSFIXATION",BrickColor.new(.075,.25,.65).Color,MAINRUINCOLOR2,"SciFi")
newTheme("rbxassetid://1538860798",0,1,1.25)
end
if k == "5" and attack == false and Mode ~= 15 then
storehumanoidWS = 70
Mode = 15
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new(1,1,1).Color -- 1,.65,.3
MAINRUINCOLOR2 = BrickColor.new(.45,.45,.5).Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("JUCIDIAN",BrickColor.new(1,1,1).Color,MAINRUINCOLOR2,"SciFi")
newTheme("rbxassetid://4536965761",0,1,1.25)
end
if k == "6" and attack == false and Mode ~= 16 then
storehumanoidWS = 16
Mode = 16
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Royal purple").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("SYNOPHASIS",BrickColor.new(1,1,1).Color,MAINRUINCOLOR,"Code")
newTheme("rbxassetid://916589587",0,1,1.25)
end
if k == "7" and attack == false and Mode ~= 17 then
storehumanoidWS = 16
Mode = 17
-- Credit to Derpz because this mode is based off of him
hum.WalkSpeed = storehumanoidWS
MAINRUINCOLOR = BrickColor.new("Toothpaste").Color
MAINRUINCOLOR2 = BrickColor.new("White").Color
RecolorThing(MAINRUINCOLOR,MAINRUINCOLOR2,MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
RecolorTextAndRename("Preservative",BrickColor.new(1,1,1).Color,MAINRUINCOLOR,"Arcade")
newTheme("rbxassetid://3252056632",0,1,1.25)
end
end
if k == "l" and mutedtog == false then
mutedtog = true
kan:Pause()
elseif k == "l" and mutedtog == true then
mutedtog = false
kan:Resume()
end
if k == ";" and attack == false and hum.Health ~= hum.MaxHealth then
Heal()
end
if k == "-" then
switch = switch + 1
if switch > 2 then
switch = 1
end
end
if k == "t" and attack == false and Mode == 4 then
newbosschatfunc("Getting kinda hot in here huh?",modet.TextColor3,modet.TextStrokeColor3,250)
elseif k == "t" and attack == false and Mode == 6 then
	attack = true
	hum.WalkSpeed = 0
	newbosschatfunc("Ehehe~",modet.TextStrokeColor3,modet.TextStrokeColor3,250)
for i = 0,20,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) + 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7 - 5 * math.cos(sine / 44)),math.rad(0),math.rad(-6 - 3 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) - 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 + 5 * math.cos(sine / 44)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.05 * math.cos(sine / 44),0 + 0.03 * math.cos(sine / 34),-0.05 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 - 5 * math.cos(sine / 44)),math.rad(-5)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5 - 2.5 * math.cos(sine / 28)),math.rad(10 + 5 * math.cos(sine / 62)),math.rad(17 + 5 * math.cos(sine / 59))),.1)
RW.C0=clerp(RW.C0,cf(0.8,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(-10 - 3 * math.cos(sine / 53)),math.rad(0),math.rad(-130 + 2 * math.cos(sine / 37))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.1 * math.cos(sine / 28),0.2)*angles(math.rad(-20),math.rad(0),math.rad(30)),.1)
end
	newbosschatfunc("Stop it~",modet.TextStrokeColor3,modet.TextStrokeColor3,250)
for i = 0,20,0.1 do
swait()
RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 28) + 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(7 - 5 * math.cos(sine / 44)),math.rad(0),math.rad(-6 - 3 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 28) - 0.05 * math.cos(sine / 44),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(3 + 5 * math.cos(sine / 44)),math.rad(0),math.rad(0 + 3 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.05 * math.cos(sine / 44),0 + 0.03 * math.cos(sine / 34),-0.05 + 0.05 * math.cos(sine / 28))*angles(math.rad(0 - 3 * math.cos(sine / 34)),math.rad(0 - 5 * math.cos(sine / 44)),math.rad(-5)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5 - 2.5 * math.cos(sine / 28)),math.rad(10 + 5 * math.cos(sine / 62)),math.rad(17 + 5 * math.cos(sine / 59))),.1)
RW.C0=clerp(RW.C0,cf(0.9,0.5 + 0.1 * math.cos(sine / 28),-0.45)*angles(math.rad(-10 - 3 * math.cos(sine / 53)),math.rad(0),math.rad(-90 + 2 * math.cos(sine / 37))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.025 * math.cos(sine / 45),-0.5)*angles(math.rad(89 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(67 - 4 * math.cos(sine / 45))),.1)
end
hum.WalkSpeed = storehumanoidWS
attack = false
end
if k == "]" and switchb == false then
MLT.Eth:TweenPosition(UDim2.new(.011,0,.2,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quint,.8,true)
wait(.6)
switchb = true
elseif k == "]" and switchb == true then
MLT.Eth:TweenPosition(UDim2.new(.011,0,1.1,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quint,.8,true)
wait(.6)
switchb = false
end
if k == "z" and attack == false and Mode == 61 then
Reanimated()
end
if k == "z" and attack == false and Mode == 4 then
fireboll()
end
if k == "v" and attack == false and Mode == 4 then
ashes()
end
end)

spawn(function()
while true do
swait()
if BarrierEnabled == false then
--Automatic-Healing-System (AHS)
hum.Health = hum.Health + 1
hum.MaxHealth = hum.MaxHealth + 1
elseif BarrierEnabled == true then
-- no
end
end
end)

plr.Chatted:connect(function(msg)
newbosschatfunc(msg,MAINRUINCOLOR,MAINRUINCOLOR2,250)
end)

coroutine.resume(coroutine.create(function()
	while true do
		swait()
		lepos = CFrame.new(math.random(-6,6),10,math.random(-6,6))
		if Mode == 8 then
	sphereMKr(6,14/45,"Add",root.CFrame*lepos*CFrame.Angles(math.rad(-90 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))),0.1,0.1,3,0,MAINRUINCOLOR,0)		
		end
end
end))

coroutine.resume(coroutine.create(function() -- U-K-E's Effects
	while true do
		swait()
if Mode == 6 then
swait(25)
sphere2(4,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.25,0,0.25,MAINRUINCOLOR)
sphere2(5,"Add",root.CFrame*CFrame.new(0,-3,0),vt(1,1,1),0.5,0,0.5,MAINRUINCOLOR)
local notsp = Instance.new("Part", char)
notsp.CanCollide = false
notsp.FormFactor = 3
notsp.Name = "Ring"
notsp.Material = "Neon"
notsp.Size = Vector3.new(10, 1, 10)
if math.random(1,6) == 1 then
notsp.Size = Vector3.new(25, 1, 25)
end
notsp.Transparency = 1
notsp.TopSurface = 0
notsp.BottomSurface = 0
notsp.Anchored = true
notsp.CFrame = root.CFrame*CFrame.new(0,-3,0)
coroutine.resume(coroutine.create(function()
local eff = Instance.new("ParticleEmitter",notsp)
eff.Texture = "rbxassetid://749327003"
eff.LightEmission = 1
eff.Color = ColorSequence.new(Color3.new(kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000,kan.PlaybackLoudness/1000))
eff.Rate = 300
eff.Lifetime = NumberRange.new(1)
eff.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0.5,0),NumberSequenceKeypoint.new(1,0,0)})
eff.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.8,0.5,0),NumberSequenceKeypoint.new(1,1,0)})
eff.Speed = NumberRange.new(20,40)
eff.Acceleration = vt(0,-75,0)
eff.Drag = 1
eff.Rotation = NumberRange.new(-10,10)
eff.VelocitySpread = 20
eff.RotSpeed = NumberRange.new(-1,1)
coroutine.resume(coroutine.create(function()
while true do
swait()
if eff.Parent ~= nil then
if Mode == 6 then
eff.Color = ColorSequence.new(Color3.new(1,0.7,0))
elseif Mode ~= 6 then
eff.Color = ColorSequence.new(MAINRUINCOLOR)
end
else
break
end
end
end))
wait(0.1)
eff.Enabled = false
end))
game:GetService("Debris"):AddItem(notsp, 5)
end
end
end))

local glitchMeshes = {}	

function genGlitches()
	clearGlitches()
	for _,v in next, char:children() do
		if(v:IsA'Part' and v.Name~='Ring')then
			local mesh = v:FindFirstChildOfClass'SpecialMesh'
			if(mesh)then
				mesh.Parent=nil
				local glitched = mesh:Clone()
				glitched.Parent=v
				table.insert(glitchMeshes,{Part=v,Original=mesh,New=glitched;})
			else
				table.insert(glitchMeshes,{Part=v,New=Instance.new("BlockMesh",v);})
			end
		elseif(v:IsA'Accessory' and v:FindFirstChild'Handle')then
			local mesh = v.Handle:FindFirstChildOfClass'SpecialMesh'
			if(mesh)then
				mesh.Parent=nil
				local glitched = mesh:Clone()
				glitched.Parent=v.Handle
				table.insert(glitchMeshes,{Part=v.Handle,Original=mesh,New=glitched;})
			else
				table.insert(glitchMeshes,{Part=v.Handle,New=Instance.new("BlockMesh",v.Handle);})
			end
		end
	end
end

function clearGlitches()
	for _,v in next, glitchMeshes do
		if(v.Original)then
			v.Original.Parent=v.Part
		end
		v.New:destroy()
	end
	glitchMeshes={}
end

function causeGlitch(intensity)
	local intensity = intensity or 1
	for _,v in next, glitchMeshes do
		v.New.Offset=Vector3.new((math.random(-1,1)/10)*intensity,(math.random(-1,1)/10)*intensity,(math.random(-1,1)/10)*intensity)
	end
end

local Glitching=false
local lastGlitch=tick()
local static = Instance.new("Sound")
static.Volume=1
static.SoundId='rbxassetid://0'
					local orig=kan:Clone()
					orig.Parent = char
					orig:Stop()
					orig.SoundId=kan.SoundId
					orig.Name = "noob"

coroutine.wrap(function()
	while true do
		swait()
		if(Mode==61 or Mode==7)then
			if(tick()-lastGlitch>=(math.random()*2) and math.random(0,30)==1 and not Glitching)then
				genGlitches()
				Glitching=true
				static.Parent=tors
				wait()
				static:Play()
				orig:Play()
				local start=tick()
				repeat swait()
					orig.SoundId=kan.SoundId
					local quikmath=math.random(1,150)
					orig.TimePosition=quikmath
					for i,v in pairs(char:GetChildren())do
						if v:IsA("Part") or v:IsA("BasePart") then
					v.BrickColor = BrickColor.Random()
					v.Material = "Neon"
					end
					end
					causeGlitch(5)
				until tick()-start>=(math.random()*2)+0.1
				lastGlitch=tick()
				Glitching=false
				clearGlitches()
				static:Stop()
				orig:Stop()
				for i,v in pairs(char:GetChildren())do
						if v:IsA("Part") or v:IsA("BasePart") then
				v.BrickColor = BrickColor.new("Nougat")
				v.Material = "Plastic"
						end
						end
				static.Parent=nil
			end
		end
	end	
end)()

coroutine.resume(coroutine.create(function()
while true do
swait()
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
if hitfloor ~= nil then
	if Mode == 1 then
sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0),vt(3,0.55,3),0.025 + kan.PlaybackLoudness/2000,-0.01,0.025 + kan.PlaybackLoudness/2000,MAINRUINCOLOR)
sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0),vt(3,0.55,3),0.025 + kan.PlaybackLoudness/2000,-0.01,0.025 + kan.PlaybackLoudness/2000,MAINRUINCOLOR2)
sphereMKn(math.random(4,8),math.random(20,30)/100,"Add",root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1,1,1,-0.01,MAINRUINCOLOR,0,3)
sphereMKn(math.random(4,8),math.random(20,30)/100,"Add",root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1,1,1,-0.01,MAINRUINCOLOR2,0,3)
elseif Mode == 2 then
	local randsiz = math.random(10,70)/10
	sphereMK(5,math.random(50,150)/300,"Add",root.CFrame*CFrame.new(math.random(-20,20),-10,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.2,0.2,randsiz*2,0,MAINRUINCOLOR,0)
	sphereMK(5,math.random(10,200)/300,"Add",root.CFrame*CFrame.new(math.random(-20,20),-10,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),randsiz/10,randsiz/10,randsiz/10,0,MAINRUINCOLOR2,0)
	elseif Mode == 4 then
sphereMKn(math.random(4,8),math.random(20,30)/100,"Add",root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1,1,1,-0.01,MAINRUINCOLOR,0,3)
sphereMKn(math.random(4,8),math.random(20,30)/100,"Add",root.CFrame*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),1,1,1,-0.01,MAINRUINCOLOR2,0,3)
	elseif Mode == 5 then
			local randsiz = math.random(10,70)/10
	sphereMK(5,math.random(50,150)/300,"Add",root.CFrame*CFrame.new(math.random(-20,20),-10,math.random(-20,20))*CFrame.Angles(math.rad(90 + math.random(-10,10)),math.rad(math.random(-10,10)),math.rad(math.random(-10,10))),0.2,0.2,randsiz*2,0,MAINRUINCOLOR,0)
	sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(0 + 700 * math.cos(sine / 200)),0),vt(0,0,0),0.005,-0.001,0.1 + kan.PlaybackLoudness/2000,MAINRUINCOLOR)
sphere2(3,"Add",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(0,math.rad(90 + 700 * math.cos(sine / 200)),0),vt(0,0,0),0.005,-0.001,0.1 + kan.PlaybackLoudness/2000,MAINRUINCOLOR)
slash(math.random(50,100)/10,5,true,"Normal","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-7,7)),math.rad(math.random(-360,360)),math.rad(math.random(-7,7))),vt(0.01,0.01,0.01),math.random(5,50)/250,MAINRUINCOLOR)
	elseif Mode == 10 then
		slash(math.random(50,100)/10,5,true,"Normal","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-7,7)),math.rad(math.random(-360,360)),math.rad(math.random(-7,7))),vt(0.01,0.01,0.01),math.random(5,50)/250,MAINRUINCOLOR2)
	sphereRotMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-20,20)),math.rad(math.random(-20,20)),math.rad(math.random(-20,20))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
	elseif Mode == 11 or Mode == 12 then
		slash(math.random(50,100)/10,5,true,"Normal","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-7,7)),math.rad(math.random(-360,360)),math.rad(math.random(-7,7))),vt(0.01,0.01,0.01),math.random(5,100)/250,MAINRUINCOLOR2)
	sphereRotMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
	sphereRotMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,MAINRUINCOLOR2,0)
	elseif Mode == 61 or Mode == 3 then
	sphereMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
	sphereMK(5,math.random(15,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50))),0.75,0.75,10,-0.0075,MAINRUINCOLOR2,0)		
	elseif Mode == 13 then
		slash(math.random(50,100)/10,5,true,"Normal","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-7,7)),math.rad(math.random(-360,360)),math.rad(math.random(-7,7))),vt(0.01,0.01,0.01),math.random(5,100)/250,MAINRUINCOLOR2)
		sphereMK(5,math.random(30,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-70,80)),math.rad(math.random(-70,80)),math.rad(math.random(-70,80))),0.75,0.75,10,-0.0075,MAINRUINCOLOR,0)
	sphereMK(5,math.random(30,50)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-70,80)),math.rad(math.random(-70,80)),math.rad(math.random(-70,80))),0.75,0.75,10,-0.0075,MAINRUINCOLOR2,0)
	elseif Mode == 16 then
		sphereMK(2,math.random(15,20)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.5,0.5,0.3,-0.0075,MAINRUINCOLOR,0)
	sphereMK(2,math.random(15,20)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90 + math.random(-1,1)),math.rad(math.random(-1,1)),math.rad(math.random(-1,1))),0.5,0.5,0.3,-0.0075,MAINRUINCOLOR2,0)		
		slash(math.random(50,100)/10,5,true,"Normal","Add","Out",root.CFrame*CFrame.new(0,-3,0)*CFrame.Angles(math.rad(math.random(-7,7)),math.rad(math.random(-360,360)),math.rad(math.random(-7,7))),vt(0.01,0.01,0.01),math.random(5,50)/250,MAINRUINCOLOR2)
	end
end
end
end))

hum.Died:Connect(function()
if BarrierEnabled == true then
hum.Parent = nil
hum.MaxHealth=8000
hum.Health = hum.MaxHealth
hum.Parent = char
for i,v in pairs(Refit:GetChildren())do
v.Enabled = true
v.Color = ColorSequence.new(MAINRUINCOLOR)
spawn(function()
	wait(2)
v.Enabled = false
end)
end
	shardEffect(char.Torso.CFrame * CFrame.new(0, -0.5, 0), 255, 0, 0)
	shardEffect(char.Torso.CFrame * CFrame.new(0, -0.5, 0), 255, 0, 0)
CFuncs["Sound"].Create("rbxassetid://2978605361", root, 10, 1)
for i = 0,20 do
sphere2(5,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(3,3,3),-0.03,15,-0.03,MAINRUINCOLOR)
end

spawn(function()
Gui.Stats.Barrier.Text = "BARRIER DESTROYED"
BarrierEnabled=false
end)
elseif BarrierEnabled == false then
	Gui.Stats.Health.Text = "HP: 0/8000"
for i,v in pairs(workspace.Terrain:GetChildren())do
v:Destroy()
end
kan:Stop()
CFuncs["Sound"].Create("rbxassetid://2613355772", root, 10, 1)
hum.BreakJointsOnDeath = true
dmgnr(Character)
end	
end)


local sng = nil
local anid = nil
local mps = game:GetService("MarketplaceService")
local scrg = Instance.new("ScreenGui",plr.PlayerGui)
scrg.Name = "who"
function bit(live)
	local siz = math.random(5,15)
	local frm = Instance.new("Frame",scrg)
	frm.Size = UDim2.new(0,siz,0,siz)
	frm.BackgroundTransparency = 0
	frm.BorderSizePixel = 0
	frm.Rotation = math.random(-360,360)
	frm.Position = UDim2.new(math.random(1,100)/100,0,1,0)
	local val = 0.025
	coroutine.resume(coroutine.create(function()
	for i = 0, 24/live do
		swait()
		frm.BackgroundColor3 = MAINRUINCOLOR2
		val = val - 0.001*live
		frm.Rotation = frm.Rotation + 5
		frm.BackgroundTransparency = frm.BackgroundTransparency + 0.04*live
		frm.Position = frm.Position - UDim2.new(0,0,val,0)
	end
	frm:Destroy()
	end))
end
local glw2 = Instance.new("ImageLabel",scrg)
glw2.BackgroundTransparency = 1
glw2.BackgroundColor3 = Color3.new(0,0,0)
glw2.Image = "rbxassetid://2288875354"
glw2.Size = UDim2.new(1,0,0.25,0)
glw2.ImageColor3 = MAINRUINCOLOR2
glw2.ImageTransparency = 0.75
glw2.Position = UDim2.new(0,0,0.75,0)


-- fuck you reset character
hum.BreakJointsOnDeath = false

hum.WalkSpeed = storehumanoidWS 
Humanoid.Name = plr.Name
Humanoid.MaxHealth = DefenceHealthMax
Humanoid.Health = DefenceHealth
rval = 0
rval2 = 0
local rotperm = 0
idleanim=.4
while true do
		bit(math.random(8,15)/10)
if mutedtog == false then
kan.Volume = ORVOL
elseif mutedtog == true then
kan.Volume = 0
end
kan.PlaybackSpeed = ORPIT
kan.Pitch = ORPIT
kan.Looped = true
kan.Parent = char
CameraManager()
swait()
if BarrierEnabled == true then
DefenceHealthMax = hum.MaxHealth
DefenceHealth = hum.Health
else
DefenceHealth = 0
end
haloweld.C0=clerp(haloweld.C0,cf(0,0,0)*angles(math.rad(0 - 4 * math.cos(sine/32)),math.rad(0),math.rad(0 - 4 * math.sin(sine/32))),.3)
modet.Position = UDim2.new(0,0,0,0)
modet.Rotation = -5 * math.cos(sine / 32)
fx1.Rotation = fx1.Rotation + 8
fx2.Rotation = fx2.Rotation + 8
glw2.ImageColor3 = MAINRUINCOLOR2
	Gui.Stats.Position = UDim2.new(0.25 + 0.1 * math.cos(sine/60),0,0.893 + 0.02 * math.sin(sine/60),0)
Gui.Ring.Rotation = Gui.Ring.Rotation - kan.PlaybackLoudness/50 + 1
Gui.Ring2.Rotation = Gui.Ring2.Rotation + kan.PlaybackLoudness/40 - 1
Gui.Ring3.Rotation = Gui.Ring3.Rotation - kan.PlaybackLoudness/32 + 1
Gui.Ring4.Rotation = Gui.Ring4.Rotation + kan.PlaybackLoudness/22 - 1
Gui.TopBar.BackgroundColor3 = Color3.new(0,0,0)
Gui.BottomBar.BackgroundColor3 = Color3.new(0,0,0)
		--	sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",rarm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,BrickColor.new("Really red").Color,0,1)
	--		sphereMKn(math.random(4,8),math.random(2,8)/100,"Add",larm.CFrame*CFrame.new(math.random(-6,6)/10,-0.5 + math.random(-10,10)/10,math.random(-6,6)/10)*CFrame.Angles(math.rad(90 + math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),1,1,1,-0.01,BrickColor.new("Really red").Color,0,1)
--trailMK(math.random(4,6),math.random(1,500)/1000,"Add",root.CFrame*CFrame.Angles(0,math.rad(0),0)*CFrame.new(math.random(-15,15),-3,math.random(-15,15))*CFrame.Angles(math.rad(90 + math.random(-6,6)),math.rad(math.random(-6,6)),math.rad(math.random(-6,6))),1,-0.0025,BrickColor.new("Really red").Color,0)
Humanoid.CameraOffset = (RootPart.CFrame:toObjectSpace(Head.CFrame)).p - Vector3.new(0, 1.25, 0)
imgca.Rotation = imgca.Rotation + 1
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
if Mode == 1 then
rval = rval + 6.5
handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.3)
elseif Mode == 61 then
	rval = rval - 1 + kan.PlaybackLoudness/30
handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.3)

elseif Mode == 5 then
	rval = rval + 6.5
handleweld.C0=clerp(handleweld.C0,cf(0,-6,0)*angles(math.rad(-90),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,-4,0),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,7,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,7,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,7,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.3)
elseif Mode == 3 then
	if Anim~="Run" then
	handleweld.C0=clerp(handleweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,3.5,1.75 + 0.1 * math.sin(sine1/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(70-30*math.cos(sine / 28))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,1.75+ 0.15 * math.sin(sine2/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(80-40*math.cos(sine / 28))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,1.75+ 0.2 * math.sin(sine3/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(90-50*math.cos(sine / 28))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,3.5,1.75+ 0.1 * math.sin(sine1/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(-70+30*math.cos(sine / 28))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,1.75+ 0.15 * math.sin(sine2/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(-80+40*math.cos(sine / 28))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,1.75+ 0.2 * math.sin(sine3/28))*angles(math.rad(5 + 10 * math.cos(sine / 21)),0,math.rad(-90+50*math.cos(sine / 28))),.3)
end
if Anim=="Run" then
	handleweld.C0=clerp(handleweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,3.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(50)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(60)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(70)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,3.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(-50)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(-60)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 0 * math.cos(sine / 21)),0,math.rad(-70)),.3)
end
elseif Mode == 7 then
handleweld.C0=clerp(handleweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(100+15*math.cos(sine/32))),.3)
lwing2weld.C1=clerp(lwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(145+25*math.cos(sine/32))),.3)
lwing3weld.C1=clerp(lwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(190+35*math.cos(sine/32))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(-100-15*math.cos(sine/32))),.3)
rwing2weld.C1=clerp(rwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(-145-25*math.cos(sine/32))),.3)
rwing3weld.C1=clerp(rwing1weld.C1,cf(0,2.5,1.75)*angles(math.rad(5 + 10 * math.cos(sine / 32)),0,math.rad(-190-35*math.cos(sine/32))),.3)
elseif Mode == 8 then
	rval = rval + 6
handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 - rval/3)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval*0.3)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval/2)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 + rval/5)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval*2)),.3)
elseif Mode == 9 or Mode == 2 or Mode == 4 or Mode == 6 or Mode == 13  or Mode == 14 or Mode == 15 then
handleweld.C0=clerp(handleweld.C0,cf(0,1.6,-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,1.6,1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 + 5 * math.cos(sine / 56))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 + 5 * math.cos(sine / 56))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 + 5 * math.cos(sine / 56))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 - 5 * math.cos(sine / 56))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 - 5 * math.cos(sine / 56))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 25 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 - 5 * math.cos(sine / 56))),.3)
elseif Mode == 10 or Mode == 11 or Mode == 12 then
handleweld.C0=clerp(handleweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),-0.4)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,cf(0,2.3 - .6 * math.cos(sine/45),1)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(90 - 30 * math.cos(sine / 45))),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(130 - 30 * math.cos(sine / 45))),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(50 - 30 * math.cos(sine / 45))),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 36),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 36)),math.rad(-90 + 30 * math.cos(sine / 45))),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 38),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 37)),math.rad(-130 + 30 * math.cos(sine / 45))),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,1.85 + 0.15 * math.cos(sine / 41),0)*angles(math.rad(0 + 2 * math.cos(sine / 45)),math.rad(0 - 2 * math.cos(sine / 51)),math.rad(-50 + 30 * math.cos(sine / 45))),.3)
elseif Mode == 16 then
rval = rval - 4 + kan.PlaybackLoudness/130
handleweld.C0=clerp(handleweld.C0,cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.3)
rotweld.C0=clerp(rotweld.C0,CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*cf(0,0,2),.3)
lwing1weld.C1=clerp(lwing1weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(90 + rval)),.3)
lwing2weld.C1=clerp(lwing2weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-147.5 + rval)),.3)
lwing3weld.C1=clerp(lwing3weld.C1,cf(0,2.5,0 + 0.2 * math.cos(sine / 20))*angles(math.rad(0 - 5 * math.cos(sine / 20)),math.rad(0),math.rad(-32.5 + rval)),.3)
rwing1weld.C1=clerp(rwing1weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(-90 - rval)),.3)
rwing2weld.C1=clerp(rwing2weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(147.5 - rval)),.3)
rwing3weld.C1=clerp(rwing3weld.C1,cf(0,2.5,0 - 0.2 * math.cos(sine / 20))*angles(math.rad(0 + 5 * math.cos(sine / 20)),math.rad(0),math.rad(32.5 - rval)),.3)

end
--bguis.Size = UDim2.new(15 + 3 * math.cos(sine/32), 0, 15 + 3 * math.cos(sine/32), 0)
--block2(7,math.random(1,10)/45,"Add",root.CFrame*CFrame.new(math.random(-25,25),-10,math.random(-25,25))*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.75,0.75,kan.PlaybackLoudness/40,-0.0075,MAINRUINCOLOR,0)
--shard1(2,0.25,"Add",root.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0,2,2,0,BrickColor.new("Really red"),2)
if BarrierEnabled == true then
Gui.Stats.Barrier.Text = "BARRIER: ".. hum.Health.. "/".. hum.MaxHealth
elseif BarrierEnabled == false then
	Gui.Stats.Health.Text = "HEALTH: ".. hum.Health.. "/".. hum.MaxHealth
end
Gui.Stats.Attack.Text = "ATTACK: x".. attackmultiplier
Gui.Stats.Level.Text = "LEVEL: ".. level
bilguit.StudsOffset = Vector3.new(0 + 0.6 * math.cos(sine/28),5 + 0.6 * math.sin(sine/32),0)
 sine = sine + change
if barrier1 >= 16 then
sine1= sine1 + change
barrier1 = 16
else
barrier1 = barrier1 + 1
end
if barrier2 >= 32 then
sine2 = sine2 + change
barrier2 = 32
else
barrier2 = barrier2 + 1
end
if barrier3 >= 48 then
sine3 = sine3 + change
barrier3 = 48
else
barrier3 = barrier3 + 1
end
if Mode == 4 then
Fire1.Enabled = true
Fire2.Enabled = true
Star1.Enabled = false
Star2.Enabled = false
elseif Mode == 5 then
	Star1.Enabled = true
Star2.Enabled = true
Fire1.Enabled = false
Fire2.Enabled = false
elseif Mode ~= 4 and Mode ~= 5 then
Fire1.Enabled = false
Fire2.Enabled = false
Star1.Enabled = false
Star2.Enabled = false
end
if levelnum >= 100 and level <= 100 then
level = level + 1
levelnum = 0
hum.MaxHealth = hum.MaxHealth + 2000
hum.Health = hum.MaxHealth
attackmultiplier = attackmultiplier + 1
spawn(function()
levelup()
end)
end
rval2 = rval2 + 2
for i,v in pairs(visu)do
	local mrad = math.random(1600,4000)
	local mrad2 = math.random(5000,7000)
	local norad = math.random(0,8)
v:TweenSize(UDim2.new(0, 15, -(kan.PlaybackLoudness)/mrad*norad, 0), "Out", "Quart", 2,true)
v.Transparency = 0.9 -kan.PlaybackLoudness/mrad2*norad
end
if(Hue > 360)then Hue = 0 end
Hue = Hue + 1
ringgu.Ring1.Orientation = Vector3.new(rval,rval2,rval2)
ringgu.Ring2.Orientation = Vector3.new(rval,-rval,rval2)
ringgu.Ring3.Orientation = Vector3.new(rval2,rval2,-rval)
ringgu.Ring4.Orientation = Vector3.new(-rval2,-rval,rval)
spawn(function()
	swait()
if Mode == 13 then
RecolorThingQuiet(MAINRUINCOLOR,Color3.fromRGB(98/2 + 98/2 * math.cos(sine/18), 37/2 + 37/2 * math.cos(sine/18), 209/2 + 209/2 * math.cos(sine/18)),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
MAINRUINCOLOR2 = Color3.fromRGB(98/2 + 98/2 * math.cos(sine/18), 37/2 + 37/2 * math.cos(sine/18), 209/2 + 209/2 * math.cos(sine/18))
elseif Mode == 61 then
RecolorThingQuiet(MAINRUINCOLOR,Color3.fromRGB(255/2 + 255/2 * math.cos(sine/10),0,0),MAINRUINCOLOR,MAINRUINCOLOR,MAINRUINCOLOR,1,MAINRUINCOLOR,1,MAINRUINCOLOR,false,false)
MAINRUINCOLOR2 = Color3.fromRGB(255/2 + 255/2 * math.cos(sine/10),0,0)
end
end)
if armorexist == true then
rarm.RuinXII.Weld.Trail.Color = ColorSequence.new(MAINRUINCOLOR2)
larm.RuinXII.Weld.Trail.Color = ColorSequence.new(MAINRUINCOLOR)
end
if equipped==true or equipped==false then
if attack==false then
idle=idle+1
else
idle=0
end
if idle>=500 then
if attack==false then
--Sheath()
end
end
ringgu.CoreOrb2.Orientation = Vector3.new(0 + 24 * math.sin(sine / 15),0 - 35 * math.cos(sine / 17),0 + 24 * math.cos(sine / 18))
if RootPart.Velocity.y > 1 and hitfloor==nil then 
Anim="Jump"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(-10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(25)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-5),math.rad(0),math.rad(-25)),.1)
end
elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
Anim="Fall"
if attack==false then
RH.C0=clerp(RH.C0,cf(1,-0.35 - 0.05 * math.cos(sine / 25),-0.75)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(-20)),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 25),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(20)),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.05 * math.cos(sine / 25))*angles(math.rad(10),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(2.5),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(55)),.1)
LW.C0=clerp(LW.C0,cf(-1.45,0.5 + 0.1 * math.cos(sine / 25),0)*angles(math.rad(-15),math.rad(0),math.rad(-55)),.1)
end
elseif torvel<1 and hitfloor~=nil then
Anim="Idle"
if attack==false then
if Mode == 1 then
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/26),0)*angles(math.rad(-35.1),math.rad(-35.5),math.rad(-22.2))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1.1,-1-0.1 * math.cos(sine/26),-0.4)*angles(math.rad(26),math.rad(11.2),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.2,-1.3-0.1 * math.cos(sine/26),0)*angles(math.rad(-11.8),math.rad(-30.9),math.rad(-22.2))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.4,-0.3)*angles(math.rad(74.4),math.rad(0 + 5 * math.sin(sine/32)),math.rad(42.4 + 10 * math.sin(sine/26))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.6,-0.3)*angles(math.rad(-41.3),math.rad(13.5 + 7 * math.cos(sine/32)),math.rad(33.7)),Alpha)
  	Torso.Neck.C0 = clerp(Torso.Neck.C0,necko*angles(math.rad(-20 +7 * math.sin(sine/26)),math.rad(0 + 6 * math.sin(sine/32)),math.rad(30)),Alpha)
elseif Mode == 2 then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 42),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 42),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(0 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.1 * math.cos(sine / 42),-0.1 + 0.05 * math.cos(sine / 32))*angles(math.rad(0 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(-10)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(10 + 2 * math.cos(sine / 53))),.1)
RW.C0=clerp(RW.C0,cf(1,0.35 + 0.2 * math.cos(sine / 42),-0.5)*angles(math.rad(62 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(-82 + 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1,0.5 + 0.2 * math.cos(sine / 42),-0.45)*angles(math.rad(23 - 2 * math.cos(sine / 58)),math.rad(0),math.rad(38 - 3 * math.cos(sine / 57) )),.1)
elseif Mode == 3 then
	RH.C0=clerp(RH.C0,cf(1,-0.65,-0.3)*angles(math.rad(-15),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3 + 0.5 * math.cos(sine / 28))*angles(math.rad(0 - 10 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-15),math.rad(20)),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(15),math.rad(-20)),.1)
elseif Mode == 4 then
RH.C0=clerp(RH.C0,cf(1,-1 - 0.1 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.1 * math.cos(sine / 28),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.1 * math.cos(sine / 28))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 2.5 * math.cos(sine / 28)),math.rad(0),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(.8,0.5 + 0.2 * math.cos(sine / 28),-0.7)*angles(math.rad(24),math.rad(0),math.rad(-78)),.1)
LW.C0=clerp(LW.C0,cf(-.8,0.5 + 0.2 * math.cos(sine / 28),-0.66)*angles(math.rad(-3),math.rad(0),math.rad(82)),.1)
elseif Mode == 5 then
RH.C0=clerp(RH.C0,cf(1,-0.3,-0.6)*angles(math.rad(-10 - 5 * math.sin(sine/32)),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 34))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,3 + 0.5 * math.cos(sine / 32))*angles(math.rad(0 - 1 * math.cos(sine / 34)),math.rad(0),math.rad(0)),.1)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(7 + 15 * math.cos(sine / 32)),math.rad(0 + 20 * math.cos(sine/64)),math.rad(0)),.1)
RW.C0=clerp(RW.C0,cf(1.3,0.5 + 0.3 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-20),math.rad(14 + 18 * math.sin(sine/32))),.1)
LW.C0=clerp(LW.C0,cf(-1.3,0.5 + 0.3 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(20),math.rad(-14 - 18 * math.sin(sine/32))),.1)
elseif Mode == 6 then
	  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/32),0)*angles(math.rad(0),math.rad(1.5),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/32),0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.2,-1.2 - 0.1 * math.cos(sine/32),0)*angles(math.rad(-14.8),math.rad(0),math.rad(-14.9))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.8,0.3 + 0.2 * math.cos(sine/32),-0.5)*angles(math.rad(40.8),math.rad(-20.4),math.rad(21.8)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.9,0.3 + 0.2 * math.cos(sine/32),-0.4)*angles(math.rad(57.5),math.rad(35),math.rad(-31)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.4)*angles(math.rad(-23.7),math.rad(-35.8),math.rad(0))*necko,Alpha)
elseif Mode == 61 then
	  	local Alpha = .1
		if(math.random(1,25)==5)then
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(math.random(-25,25))+math.rad(25 - 2.5 * math.sin(sine / 32)),math.rad(math.random(-25,25))+math.rad(0),math.rad(math.random(-25,25))+math.rad(-25 - 1 * math.cos(sine / 44))),1)
	else
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(25 - 2.5 * math.sin(sine / 32)),math.rad(0),math.rad(-25 - 1 * math.cos(sine / 44))),0.1)
	end
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/23),0)*angles(math.rad(-7.7),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/23),-0.1)*angles(math.rad(4.6),math.rad(20.5),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1 - 0.1 * math.cos(sine/23),-0.1)*angles(math.rad(5),math.rad(-16.6),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1,0.5 + 0.2 * math.cos(sine/23),0.4)*angles(math.rad(-17.1 + math.random(-10,10)),math.rad(0 + math.random(-10,10)),math.rad(37.7 + math.random(-10,10))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,0.5 + 0.2 * math.cos(sine/23),0.4)*angles(math.rad(-158.3 + math.random(-10,10)),math.rad(0 + math.random(-10,10)),math.rad(-48.1 + math.random(-10,10))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.4)*angles(math.rad(-23.1),math.rad(0),math.rad(0))*necko,Alpha)
elseif Mode == 7 then
	RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56))+math.rad(-25 - 1 * math.cos(sine / 44)),math.rad(-5 - 2 * math.cos(sine / 32))),.1)
LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 32),0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-1 + 2 * math.cos(sine / 32))),.1)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0.02 + 0.02 * math.cos(sine / 32),0 + 0.05 * math.cos(sine / 32))*angles(math.rad(2 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(25 + 1 * math.cos(sine / 44))),.1)
	if(math.random(1,25)==5)then
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(math.random(-25,25))+math.rad(25 - 2.5 * math.sin(sine / 32)),math.rad(math.random(-25,25))+math.rad(0),math.rad(math.random(-25,25))+math.rad(-25 - 1 * math.cos(sine / 44))),1)
	else
		Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0, 0, 0 + ((1) - 1))*angles(math.rad(25 - 2.5 * math.sin(sine / 32)),math.rad(0),math.rad(-25 - 1 * math.cos(sine / 44))),0.1)
	end
	RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(165 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(-22 - 2 * math.cos(sine / 45))),.1)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(7 - 2 * math.cos(sine / 51)),math.rad(0 - 4 * math.cos(sine / 64)),math.rad(-22 - 2 * math.cos(sine / 45))),.1)
elseif Mode == 8 then
local Alpha = .3
      RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,0 - 0.1 * math.cos(sine/15),-0.1)*angles(math.rad(-21),math.rad(-17.7),math.rad(-18))*RootCF,Alpha)
      LH.C0 = LH.C0:lerp(cf(-1,-1.3+ 0.1 * math.cos(sine/15),0.1)*angles(math.rad(-12.7),math.rad(31.4),math.rad(6.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
      RH.C0 = RH.C0:lerp(cf(1,-0.6+ 0.1 * math.cos(sine/15),-0.5)*angles(math.rad(0),math.rad(0),math.rad(12.9))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
      LW.C0 = LW.C0:lerp(cf(-1.3,0.3 - 0.1 * math.cos(sine/30),-0.3)*angles(math.rad(37.2 -  4 * math.cos(sine/15)+ math.random(-3,3)),math.rad(29.8 +  4 * math.cos(sine/20)+ math.random(-3,3)),math.rad(15.5 +  4 * math.cos(sine/53)+ math.random(-3,3))),Alpha)
      RW.C0 = RW.C0:lerp(cf(1.4,0.6 + 0.1 * math.cos(sine/31),-0.3)*angles(math.rad(8.1 +  4 * math.cos(sine/15)+ math.random(-3,3)),math.rad(28.3 -  4 * math.cos(sine/20)+ math.random(-3,3)),math.rad(12.3 +  4 * math.cos(sine/34)+ math.random(-3,3))),Alpha)
      Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.4,0,-0.2)*angles(math.rad(11.7 + math.random(-3,3)),math.rad(23+ math.random(-3,3)),math.rad(-14.8+ math.random(-3,3)))*necko,Alpha)    
elseif Mode == 9 then
	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/15),0)*angles(math.rad(0.2 + 5 * math.cos(sine/32)),math.rad(-1.3),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/15),-0.1)*angles(math.rad(-5),math.rad(0.9),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1 - 0.1 * math.cos(sine/15),-0.1)*angles(math.rad(-1.7),math.rad(-16.5),math.rad(-1.9))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.5,0.6 + 0.2 * math.cos(sine/15),-0.9)*angles(math.rad(89.3),math.rad(1.6),math.rad(92.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.8,0.4 + 0.2 * math.cos(sine/15),-0.9)*angles(math.rad(88.3),math.rad(0),math.rad(-83.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-16.1),math.rad(-1.7),math.rad(-0.1))*necko,Alpha)
elseif Mode == 10 then
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(-0.1- 0.5 * math.cos(sine/45),6 - 2 * math.cos(sine/42),-0.7 - 0.5 * math.sin(sine/42))*angles(math.rad(-27.6),math.rad(-32.9),math.rad(-0.7))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(-5- 9 * math.cos(sine/45)),math.rad(0.9),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.8,-0.1,-0.3)*angles(math.rad(-1.7- 9 * math.cos(sine/45)),math.rad(-16.5),math.rad(-1.9))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.8,0.6,-0.5)*angles(math.rad(114.8- 4 * math.cos(sine/52)),math.rad(0.4),math.rad(83.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1,0.6,-0.7)*angles(math.rad(108.5- 5 * math.cos(sine/54)),math.rad(3.1),math.rad(-80.9)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-16.1),math.rad(-1.7),math.rad(-0.1))*necko,Alpha)
elseif Mode == 11 then
		local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(-0.1- 0.5 * math.cos(sine/45),6 - 3 * math.sin(sine/45),-0.8 - 0.7 * math.cos(sine/45))*angles(math.rad(-26.6 - 10 * math.cos(sine/45)),math.rad(42.4),math.rad(-0.8))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(-5 + 3 * math.sin(sine/42)),math.rad(0.9),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.8,-0.1,-0.3)*angles(math.rad(-1.7),math.rad(-16.5),math.rad(-1.9 * math.cos(sine/45)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.8,0)*angles(math.rad(7.8),math.rad(-5.4),math.rad(-55.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.8,0)*angles(math.rad(19.1),math.rad(-9.6),math.rad(40.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(3),math.rad(-51.4),math.rad(0.7))*necko,Alpha)
elseif Mode == 12 then
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,4.8 + 2.3 * math.cos(sine/45),0)*angles(math.rad(38.2 - 10 * math.sin(sine/45)),math.rad(26.4),math.rad(-14.1))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(24.6 - 5 * math.cos(sine/45)),math.rad(-0.8),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.8)*angles(math.rad(-37 - 5 * math.cos(sine/45)),math.rad(4.1),math.rad(0.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.1,1,0.1)*angles(math.rad(-164.6),math.rad(15.9),math.rad(53.8)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.8,0)*angles(math.rad(19.1),math.rad(-9.6),math.rad(40.3)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(-0 + 7 * math.sin(sine/45)),math.rad(-14.5),math.rad(-9.4)),Alpha)

elseif Mode == 13 then
	  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0 + 2 * math.sin(sine/45),6 - 3 * math.cos(sine/45),0)*angles(math.rad(-0.2),math.rad(29.4 - 10 * math.cos(sine/45)),math.rad(19.9))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(-22.6),math.rad(1.8),math.rad(-2.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.9)*angles(math.rad(-37),math.rad(4.1),math.rad(0.7))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.8,-0.1)*angles(math.rad(23.4),math.rad(-25.6),math.rad(-51 + 10 * math.cos(sine/45))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.8,0)*angles(math.rad(19.1),math.rad(-9.6),math.rad(40.3 - 10 * math.cos(sine/45))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.2,0.1,0.5)*angles(math.rad(-32.5),math.rad(-14.5),math.rad(-9.4))*necko,Alpha)

elseif Mode == 131 then
  	local Alpha = .1
  	TweenAnimate(RootJoint,{C0=cf(0.6,6 - 3 * math.cos(sine/45),-0.6)*angles(math.rad(-26.5),math.rad(-43.9),math.rad(-19.1))*RootCF},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LH,{C0=cf(-1,-0.3,-0.5)*angles(math.rad(-27.1),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RH,{C0=cf(1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(LW,{C0=cf(-1.3,0.9,-0.1)*angles(math.rad(148.9 + 8 * math.sin(sine/32)),math.rad(-15.3),math.rad(45.5))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(RW,{C0=cf(1.5,0.7,0)*angles(math.rad(1),math.rad(0.4),math.rad(20.8 + 10 * math.sin(sine/45)))},Alpha,'Linear','Out',0,false,0)
  	TweenAnimate(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(-3.5),math.rad(40.5),math.rad(-0.4))*necko},Alpha,'Linear','Out',0,false,0)
elseif Mode == 14 then
	local Alpha = .3
    RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 35),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 30))),.25)
    LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 35),0)*angles(math.rad(0),math.rad(-60),math.rad(0))*angles(math.rad(-9.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 30))),.25)
    RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.025 * math.cos(sine / 35))*angles(math.rad(0 - .5 * math.cos(sine / 15)),math.rad(0),math.rad(-30)),.1)
    Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 4 * math.cos(sine / 35)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(30 - 0 * math.cos(sine / 53))),.9)
    RW.C0=clerp(RW.C0,cf(1.5,.5 + 0.025 * math.cos(sine / 35), 0)*angles(math.rad(0 - 0 * math.cos(sine / 35)),math.rad(20 - 1 * math.cos(sine / 15)),math.rad(0 - 2 * math.cos(sine / 35))),1.5)
    LW.C0=clerp(LW.C0,cf(-1.5,.5 + 0.025 * math.cos(sine / 35),0)*angles(math.rad(4 - 0 * math.cos(sine / 35)),math.rad(20 - 1 * math.cos(sine / 15)),math.rad(0 + 2 * math.cos(sine / 35))),1.5)

elseif Mode == 15 then
	local Alpha = .3
    RH.C0=clerp(RH.C0,cf(1,-1 - 0.05 * math.cos(sine / 35),0)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 30))),.25)
    LH.C0=clerp(LH.C0,cf(-1,-1 - 0.05 * math.cos(sine / 35),0)*angles(math.rad(0),math.rad(-60),math.rad(0))*angles(math.rad(-9.5),math.rad(0),math.rad(0 + 1 * math.cos(sine / 30))),.25)
    RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0 + 0.025 * math.cos(sine / 35))*angles(math.rad(0 - .5 * math.cos(sine / 15)),math.rad(0),math.rad(-30)),.1)
    Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(5 - 4 * math.cos(sine / 35)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(30 - 0 * math.cos(sine / 53))),.9)
    RW.C0=clerp(RW.C0,cf(1.5,.5 + 0.025 * math.cos(sine / 35), 0)*angles(math.rad(0 - 0 * math.cos(sine / 35)),math.rad(20 - 1 * math.cos(sine / 15)),math.rad(0 - 2 * math.cos(sine / 35))),1.5)
    LW.C0=clerp(LW.C0,cf(-1.5,.5 + 0.025 * math.cos(sine / 35),0)*angles(math.rad(4 - 0 * math.cos(sine / 35)),math.rad(20 - 1 * math.cos(sine / 15)),math.rad(0 + 2 * math.cos(sine / 35))),1.5)
elseif Mode == 16 then
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,1.1 - 0.5 * math.cos(sine/32),0.1)*angles(math.rad(-19.3 - 3 * math.sin(sine/32)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.4,-0.8)*angles(math.rad(-20.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.1,0.7,-0.5)*angles(math.rad(104),math.rad(-18.4),math.rad(75.9)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1,0.8,-0.4)*angles(math.rad(127.4),math.rad(2.3),math.rad(-85.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.3)*angles(math.rad(-16.1),math.rad(0),math.rad(0))*necko,Alpha)				
end
end
elseif torvel>2 and torvel<22 and hitfloor~=nil then
Anim="Walk"
if attack==false then
	if Mode == 16 then
	RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,1.1 + 0.5 * math.cos(sine / 32))*angles(math.rad(40),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
else
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.5 + 0.05 * math.cos(sine / 3))*angles(math.rad(20 - 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8 - 0.2 * math.cos(sine / 7) / 2, 0.5 * math.sin(sine / 7))  * angles(math.rad(-10 - 40 * math.cos(sine / 7)) - rl.RotVelocity.Y / 120 + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8 + 0.2 * math.cos(sine / 7) / 2, -0.5 * math.sin(sine / 7)) * angles(math.rad(-10 + 40 * math.cos(sine / 7)) + ll.RotVelocity.Y / 120 + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
RW.C0 = clerp(RW.C0, cf(1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 - 0.5 * math.cos(sine / 7)) * angles(math.rad(78)  * math.cos(sine / 7) , math.rad(0) ,   math.rad(0) - ra.RotVelocity.Y/120), 0.3)
LW.C0 = clerp(LW.C0, cf(-1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 + 0.5 * math.cos(sine / 7)) * angles(math.rad(-78)  * math.cos(sine / 7) , math.rad(0) ,   math.rad(0) + la.RotVelocity.Y/120), 0.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.3)
end
end
elseif torvel>=22 and hitfloor~=nil then
Anim="Run"
if attack==false then
if Mode == 3 or Mode == 16 then
RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),-0.5,3 + 0.5 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
elseif Mode == 10 then
RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1- 0.5 * math.cos(sine/36),-0.7 - 0.5 * math.sin(sine/42),6 - 2 * math.cos(sine/42))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
elseif Mode == 11 then
RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(-0.1- 0.5 * math.cos(sine/32),-0.8 - 0.7 * math.cos(sine/45),6 - 3 * math.sin(sine/45))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
elseif Mode == 12 then
	RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,4.8 + 2.3 * math.cos(sine/45))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
elseif Mode == 13 then
	RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 + 2 * math.sin(sine/45),0,6 - 3 * math.cos(sine/45))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
elseif Mode == 5 then
	RH.C0=clerp(RH.C0,cf(1,-0.5,-0.6)*angles(math.rad(0),math.rad(90),math.rad(0))*angles(math.rad(1.5),math.rad(0),math.rad(-20 - 5 * math.cos(sine / 34))),.2)
LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(0),math.rad(-90),math.rad(0))*angles(math.rad(1),math.rad(0),math.rad(20 + 2 * math.cos(sine / 38))),.2)
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0 - 0.15 * math.cos(sine / 47),0,3 + 0.5 * math.cos(sine / 28))*angles(math.rad(70),math.rad(0 - root.RotVelocity.Y),math.rad(0 - root.RotVelocity.Y *4.5 + 3 * math.cos(sine / 47))),.2)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-17 - 5 * math.cos(sine / 52)),math.rad(0 - 3 * math.cos(sine / 37)),math.rad(0 + 2 * math.cos(sine / 78))),.2)
RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.05 * math.cos(sine / 28),0)*angles(math.rad(-8 - 4 * math.cos(sine / 59)),math.rad(-20 + 7 * math.cos(sine / 62)),math.rad(20 + 5 * math.cos(sine / 50))),.2)
LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.1 * math.cos(sine / 28),0)*angles(math.rad(-8 - 3 * math.cos(sine / 55)),math.rad(20 + 8 * math.cos(sine / 67)),math.rad(-20 - 4 * math.cos(sine / 29))),.2)
else
RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,-0.3,-0.05 + 0.15 * math.cos(sine / 3))*angles(math.rad(25 - 4 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - root.RotVelocity.Y - 1 * math.cos(sine / 6))),.3)
    RH.C0 = clerp(RH.C0, cf(1, -0.8 - 1 * math.cos(sine / 7) / 2, 0.6 * math.sin(sine / 7))  * angles(math.rad(-15 - 50 * math.cos(sine / 7)) - rl.RotVelocity.Y / 75 + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
    LH.C0 = clerp(LH.C0, cf(-1, -0.8 + 1 * math.cos(sine / 7) / 2, -0.6 * math.sin(sine / 7)) * angles(math.rad(-15 + 50 * math.cos(sine / 7)) + ll.RotVelocity.Y / 75 + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
RW.C0 = clerp(RW.C0, cf(1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 - 0.5 * math.cos(sine / 7)) * angles(math.rad(78)  * math.cos(sine / 7) , math.rad(-8 * math.cos(sine / 7)) ,   math.rad(6) - ra.RotVelocity.Y/75), 0.3)
LW.C0 = clerp(LW.C0, cf(-1.5, 0.5 + 0.05 * math.sin(sine / 7), 0 + 0.5 * math.cos(sine / 7)) * angles(math.rad(-78)  * math.cos(sine / 7) , math.rad(8 * math.cos(sine / 7)) ,   math.rad(-6) + la.RotVelocity.Y/75), 0.3)
Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-6 + 2 * math.cos(sine / 3)),math.rad(0 + root.RotVelocity.Y*1.5),math.rad(0 - hed.RotVelocity.Y*1.5 + 1 * math.cos(sine / 6))),.3)
end
end
end
end
end
end)